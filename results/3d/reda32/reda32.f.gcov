        -:    0:Source:results/3d/reda32/reda32.f
        -:    0:Graph:./results\3d\reda32\reda32.gcno
        -:    0:Data:./results\3d\reda32\reda32.gcda
        -:    0:Runs:1
function MAIN__ called 1 returned 100% blocks executed 100%
        1:    1:      program REDA32
        -:    2:
        -:    3:c    TESTING OF THE REDUCTION_GROUP DIRECTIVE,REDUCTION_START
        -:    4:c    DIRECTIVE,REDUCTION_WAIT DIRECTIVE.
        -:    5:c    REDUCTION GROUPE IS EXECUTED FOR DISTRIBUTED ARRAY A(N,M,K).  
        -:    6:c
        1:    7:      print *,'===START OF REDA32======================='
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:    8:C --------------------------------------------------
        1:    9:      call reda3201
call    0 returned 100%
        -:   10:C --------------------------------------------------
        1:   11:      call reda3202
call    0 returned 100%
        -:   12:C --------------------------------------------------
        1:   13:      call reda3203
call    0 returned 100%
        -:   14:C -------------------------------------------------
        1:   15:      call reda3204
call    0 returned 100%
        -:   16:C -------------------------------------------------
        -:   17:
        -:   18:C
        -:   19:C
        1:   20:      print *,'=== END OF REDA32 ========================= '    
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
function main called 1 returned 100% blocks executed 100%
        1:   21:      end
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   22:
        -:   23:
        -:   24: 
        -:   25:
        -:   26:C ----------------------------------------------------REDA3201
function reda3201_ called 1 returned 100% blocks executed 89%
        1:   27:      subroutine REDA3201
        -:   28:      integer, parameter :: N = 16,M=8,K=16,NL=1000
        -:   29:      character*8 tname
        1:   30:      integer, allocatable :: A(:,:,:),C(:,:,:)
        -:   31:      integer imin1,imint1 ,ni
        -:   32:      integer isum1,isumt1 
        -:   33:      integer imax1,imaxt1
        -:   34:                      
        -:   35:cdvm$ distribute A(BLOCK,BLOCK,*)
        -:   36:cdvm$ reduction_group smaxmin
        -:   37:
        1:   38:      tname='REDA3201'
       1*:   39:      allocate (A(N,M,K),C(N,M,K))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:   40:      NNL=NL 
        1:   41:      NN=N
        1:   42:      MM=M
        1:   43:      KK=K
        1:   44:      call sersum3m(C,NN,MM,KK,NNL,isum1)
        -:   45:
        -:   46:*dvm$ parallel (i,j,ii) on A(i,j,ii)
       17:   47:      do i=1,N
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
      145:   48:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
     2192:   49:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     2176:   50:            A(i,j,ii) = i+j+ii+NL
        -:   51:          enddo
        -:   52:        enddo
        -:   53:      enddo
        1:   54:      ni=N/2-1
        1:   55:      nj=M/2-1
        1:   56:      nii=K/2-1
        1:   57:      A(ni,nj,nii)=N+M+K+1+NL
        1:   58:      imax1=N+M+K+1+NL
        -:   59:
        -:   60:cdvm$ remote_access (A(1,1,1))
        1:   61:      imaxt1=A(1,1,1)  
        -:   62:
        1:   63:      ni=N/2
        1:   64:      nj=M/2
        1:   65:      nii=K/2 
        1:   66:      A(ni,nj,nii)=-(N+M+K+1+NL)
        1:   67:      imin1=-(N+M+K+1+NL)
        -:   68:
        -:   69:cdvm$ remote_access (A(1,1,1))
        1:   70:      imint1=A(1,1,1)
        -:   71:
        1:   72:      isumt1 = 0
        -:   73:
        -:   74:*dvm$ parallel (i,j,ii) on A(i,j,ii),
        -:   75:*dvm$*reduction(smaxmin:sum(isumt1),max(imaxt1),min(imint1))
       17:   76:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:   77:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
     2192:   78:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     2048:   79:            isumt1 = isumt1+A(i,j,ii)
     2048:   80:            if (A(i,j,ii).GT.imaxt1) imaxt1=A(i,j,ii)
     2176:   81:            if (A(i,j,ii).LT.imint1) imint1=A(i,j,ii)
        -:   82:          enddo
        -:   83:        enddo
        -:   84:      enddo
        -:   85:
        -:   86:cdvm$ reduction_start smaxmin
        -:   87:cdvm$ reduction_wait smaxmin
        -:   88:c      print *,isumt1,isum1
        -:   89:c      print *,imaxt1,imax1
        -:   90:c      print *,imint1,imin1
        -:   91:      if ((isum1 .eq.isumt1) .and.(imax1 .eq.imaxt1)
        1:   92:     *   .and.(imin1 .eq.imint1))   then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:   93:          call ansyes(tname)
call    0 returned 100%
        -:   94:      else
    #####:   95:          call ansno(tname)
call    0 never executed
        -:   96:      endif 
       1*:   97:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   98:
        1:   99:      end
        -:  100:C ----------------------------------------------------REDA3202
function reda3202_ called 1 returned 100% blocks executed 90%
        1:  101:      subroutine REDA3202
        -:  102:      integer, parameter :: N = 16,M=8,K=16,NL=1000
        -:  103:      character*8 tname
        1:  104:      integer, allocatable :: A(:,:,:),C(:,:,:)
        -:  105:      integer iprod1,iprodt1 
        1:  106:      logical, allocatable :: B(:,:,:),CL(:,:,:)
        -:  107:      logical land1,landt1,lor1,leqv1,lneqv1
        -:  108:                 
        -:  109:cdvm$ distribute A(BLOCK,*,BLOCK)    
        -:  110:cdvm$ align B(I,J,II) with A(I,J,II)      
        -:  111:cdvm$ reduction_group prodand
        -:  112:
        1:  113:      tname='REDA3202'
       1*:  114:      allocate (A(N,M,K),C(N,M,K))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
       1*:  115:      allocate (B(N,M,K),CL(N,M,K))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  116:      NNL=NL
        1:  117:      NN=N
        1:  118:      MM=M
        1:  119:      KK=K
        1:  120:      call serprod3(C,NN,MM,KK,NNL,iprod1)
call    0 returned 100%
        1:  121:      call serlog3(CL,NN,MM,KK,land1,lor1,leqv1,lneqv1)
        -:  122:
        -:  123:*dvm$ parallel (i,j,ii) on B(i,j,ii)
       17:  124:      do i=1,N
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
      145:  125:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       16:  126:          do ii=1,K,2
     1024:  127:            B(i,j,ii) = .true.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  128:          enddo
        -:  129:        enddo         
        -:  130:      enddo
        -:  131:
        -:  132:*dvm$ parallel (i,j,ii) on B(i,j,ii)
       17:  133:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  134:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       16:  135:          do ii=2,K,2 
     1024:  136:           B(i,j,ii)=.false.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  137:          enddo
        -:  138:        enddo
        -:  139:      enddo
        -:  140:
        -:  141:cdvm$ remote_access (B(1,1,1))
        1:  142:      landt1 = B(1,1,1)    
        -:  143:
        -:  144:*dvm$ parallel (i,j,ii) on A(i,j,ii)
       17:  145:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  146:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
     2192:  147:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     2176:  148:            A(i,j,ii) = i+j+ii+NL
        -:  149:          enddo
        -:  150:        enddo
        -:  151:      enddo
        -:  152:  
        -:  153:      iprodt1 = 1
        -:  154:
        -:  155:*dvm$ parallel (i,j,ii) on A(i,j,ii),
        -:  156:*dvm$*reduction(prodand:product( iprodt1 ),and(landt1))
       17:  157:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  158:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
     2192:  159:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     2048:  160:           iprodt1 = iprodt1*A(i,j,ii)
     4223:  161:           landt1 = landt1 .and.B(i,j,ii)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        -:  162:          enddo
        -:  163:        enddo
        -:  164:      enddo
        -:  165:
        -:  166:cdvm$ reduction_start prodand
        -:  167:
        -:  168:*dvm$ parallel (i,j,ii) on A(i,j,ii)
       17:  169:      do  i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  170:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
     2192:  171:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     2176:  172:            A(i,j,ii) = i+j+ii+NL
        -:  173:          enddo
        -:  174:        enddo
        -:  175:      enddo
        -:  176:cdvm$ reduction_wait prodand 
        -:  177:
        -:  178:      if ((iprod1 .eq.iprodt1)
        1:  179:     *.and. (land1 .eqv.landt1)) then       
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  180:          call ansyes(tname)
call    0 returned 100%
        -:  181:      else
    #####:  182:          call ansno(tname)
call    0 never executed
        -:  183:      endif 
       1*:  184:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
       1*:  185:      deallocate (B,CL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  186: 
        1:  187:      end   
        -:  188:
        -:  189:
        -:  190:C ----------------------------------------------------REDA3203
function reda3203_ called 1 returned 100% blocks executed 91%
        1:  191:      subroutine REDA3203
        -:  192:      integer, parameter :: N = 8, M=4,K=16,NL=1000
        -:  193:      character*8 tname
        1:  194:      integer, allocatable :: A(:,:,:),C(:,:,:)
        -:  195:      integer imax1,imaxt1 ,ni,imin1,imint1,it1,it2,jt1,jt2
        -:  196:      integer imaxloct1,iminloct1,lcoor
        -:  197:      integer coor1(3),coor2(3)
        -:  198:            
        -:  199:cdvm$ distribute A(*,BLOCK,BLOCK)    
        -:  200:cdvm$ reduction_group locmaxmin
        -:  201:
        1:  202:      tname='REDA3203'
       1*:  203:      allocate (A(N,M,K),C(N,M,K))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  204:      
        -:  205:*dvm$ parallel (i,j,ii) on A(i,j,ii)
        9:  206:      do i=1,N
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       41:  207:        do j=1,M
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
      552:  208:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      544:  209:            A(i,j,ii) = i+j+ii+NL
        -:  210:          enddo
        -:  211:        enddo
        -:  212:      enddo
        -:  213:
        1:  214:      ni=N/2
        1:  215:      nj=M/2
        1:  216:      nii=K/2
        1:  217:      A(ni,nj,nii)=N+M+K+1+NL
        1:  218:      imax1=N+M+K+1+NL
        -:  219:
        -:  220:cdvm$ remote_access (A(1,1,1))
        1:  221:      imaxt1=A(1,1,1)  
        -:  222:
        1:  223:      imaxloct1=imaxt1
        1:  224:      ni1=N/2-1
        1:  225:      nj1=M/2-1
        1:  226:      nii1=K/2-1
        1:  227:      A(ni1,nj1,nii1)=-(N+M+K+1+NL)
        1:  228:      imin1=-(N+M+K+1+NL)
        -:  229:
        -:  230:cdvm$ remote_access (A(1,1,1))      
        1:  231:      imint1=A(1,1,1)
        -:  232:
        1:  233:      iminloct1=imint1
        1:  234:      lcoor=3
        1:  235:      coor1(1)=0
        1:  236:      coor1(2)=0
        1:  237:      coor1(3)=0
        1:  238:      coor2(1)=0
        1:  239:      coor2(2)=0
        1:  240:      coor2(3)=0
        -:  241:
        -:  242:*dvm$ parallel (i,j,ii) on A(i,j,ii),
        -:  243:*dvm$*reduction(locmaxmin:max( imaxt1 ),
        -:  244:*dvm$*maxloc( imaxloct1,coor1,lcoor),
        -:  245:*dvm$*minloc( iminloct1,coor2,lcoor))
        9:  246:      do i=1,N
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       41:  247:        do j=1,M
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
      552:  248:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      512:  249:           if (A(i,j,ii).GT.imaxt1) imaxt1 =A(i,j,ii)
      512:  250:           if (A(i,j,ii).GT.imaxloct1) then
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
       21:  251:             imaxloct1=A(i,j,ii)         
       21:  252:             coor1(1)=i
       21:  253:             coor1(2)=j 
       21:  254:             coor1(3)=ii 
        -:  255:           endif
      544:  256:           if (A(i,j,ii).LT.iminloct1) then
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        1:  257:             iminloct1=A(i,j,ii)
        1:  258:             coor2(1)=i
        1:  259:             coor2(2)=j 
        1:  260:             coor2(3)=ii  
        -:  261:           endif
        -:  262:          enddo
        -:  263:        enddo
        -:  264:      enddo
        -:  265:
        -:  266:cdvm$ reduction_startlocmaxmin
        -:  267:cdvm$ reduction_wait locmaxmin
        -:  268:
        -:  269:c      print *,imax1,imaxt1,imaxloct1
        -:  270:c      print *,imin1,imint1,iminloct1
        -:  271:c      print *,it1,ni
        -:  272:c      print *,it2,ni1
        -:  273:c      print *,jt1,nj
        -:  274:c      print *,jt2,nj1
        -:  275:       if ((imaxloct1.eq.imax1).and.(iminloct1.eq.imin1).and.
        -:  276:     * (imaxt1.eq.imaxloct1).and.(coor1(1).eq.ni).and.
        -:  277:     * (coor1(2).eq.nj).and.(coor1(3).eq.nii).and.
        -:  278:     * (coor2(1).eq.ni1) .and.(coor2(2).eq.nj1) 
        1:  279:     * .and.(coor2(3).eq.nii1)) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
        1:  280:          call ansyes(tname)
call    0 returned 100%
        -:  281:      else
    #####:  282:          call ansno(tname)
call    0 never executed
        -:  283:      endif 
       1*:  284:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  285:
        1:  286:      end
        -:  287:
        -:  288:
        -:  289:C ----------------------------------------------------REDA3204
function reda3204_ called 1 returned 100% blocks executed 91%
        1:  290:      subroutine REDA3204
        -:  291:      integer, parameter :: N = 8,M=6,K=16
        -:  292:      real, parameter :: NL=1000.
        -:  293:      character*8 tname
        1:  294:      real, allocatable :: A(:,:,:),C(:,:,:)
        -:  295:      real isum1,isumt1
        -:  296:      real imax1,imaxt1 ,imin1,imint1
        -:  297:      real imaxloct1,iminloct1,NNL
        -:  298:      integer ni,ni1,lcoor
        -:  299:      integer coor1(3),coor2(3)
        -:  300:          
        -:  301:cdvm$ distribute A(BLOCK,BLOCK,*)     
        -:  302:cdvm$ reduction_group locsum
        -:  303:
        1:  304:      tname='REDA3204'
       1*:  305:      allocate (A(N,M,K),C(N,M,K))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  306:      NNL=NL 
        1:  307:      NN=N
        1:  308:      MM=M
        1:  309:      KK=K
        1:  310:      call sersum3mr(C,NN,MM,KK,NNL,isum1)
        -:  311:
        -:  312:*dvm$ parallel (i,j,ii) on A(i,j,ii)
        9:  313:      do i=1,N
call    0 returned 100%
branch  1 taken 89% (fallthrough)
branch  2 taken 11%
       57:  314:        do j=1,M
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
      824:  315:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      816:  316:            A(i,j,ii) = i+j+ii+NL
        -:  317:          enddo
        -:  318:        enddo
        -:  319:      enddo
        -:  320:
        1:  321:      ni=N/2
        1:  322:      nj=M/2
        1:  323:      nii=K/2
        1:  324:      A(ni,nj,nii)=N+M+K+1.+NL
        1:  325:      imax1=N+M+K+1.+NL
        -:  326:
        -:  327:cdvm$ remote_access (A(1,1,1))
        1:  328:      imaxt1=A(1,1,1)  
        -:  329:
        1:  330:      imaxloct1=imaxt1
        1:  331:      ni1=N/2-1
        1:  332:      nj1=M/2-1
        1:  333:      nii1=K/2-1 
        1:  334:      A(ni1,nj1,nii1)=-(N+M+K+1.+NL)
        1:  335:      imin1=-(N+M+K+1.+NL)
        -:  336:
        -:  337:cdvm$ remote_access (A(1,1,1))      
        1:  338:      imint1=A(1,1,1)
        -:  339:
        1:  340:      iminloct1=imint1
        1:  341:      isumt1 = 0.
        1:  342:      lcoor=3
        1:  343:      coor1(1)=0
        1:  344:      coor1(2)=0
        1:  345:      coor1(3)=0
        1:  346:      coor2(1)=0
        1:  347:      coor2(2)=0
        1:  348:      coor2(3)=0
        -:  349:
        -:  350:*dvm$ parallel (i,j,ii) on A(i,j,ii),
        -:  351:*dvm$*reduction(locsum:sum( isumt1 ),
        -:  352:*dvm$*maxloc( imaxloct1,coor1,lcoor),minloc( iminloct1,coor2,lcoor))
        9:  353:      do i=1,N
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       57:  354:        do j=1,M
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
      824:  355:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      768:  356:           isumt1 = isumt1+A(i,j,ii)
      768:  357:           if (A(i,j,ii).GT.imaxloct1) then
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
       23:  358:             imaxloct1=A(i,j,ii)
       23:  359:             coor1(1)=i
       23:  360:             coor1(2)=j 
       23:  361:             coor1(3)=ii  
        -:  362:           endif
      816:  363:           if (A(i,j,ii).LT.iminloct1) then
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        1:  364:             iminloct1=A(i,j,ii)
        1:  365:             coor2(1)=i
        1:  366:             coor2(2)=j 
        1:  367:             coor2(3)=ii  
        -:  368:           endif
        -:  369:          enddo
        -:  370:        enddo
        -:  371:      enddo
        -:  372:
        -:  373:cdvm$ reduction_start locsum
        -:  374:cdvm$ reduction_wait locsum
        -:  375:c      print *,A
        -:  376:c      print *,imax1,imaxt1,imaxloct1
        -:  377:c      print *,imin1,imint1,iminloct1
        -:  378:     
        -:  379:c      print *,isum1,isumt1
        -:  380:c      print *,it1,ni
        -:  381:c      print *,it2,ni1
        -:  382:c      print *,jt1,nj
        -:  383:c      print *,jt2,nj1
        -:  384:      if ((imaxloct1.eq.imax1).and.(iminloct1.eq.imin1)
        -:  385:     *.and.(isumt1.eq.isum1).and.(coor1(1).eq.ni)
        -:  386:     *.and.(coor2(1).eq.ni1).and.(coor1(2).eq.nj) 
        -:  387:     *.and.(coor2(2).eq.nj1)
        1:  388:     *.and.(coor1(3).eq.nii).and.(coor2(3).eq.nii1))then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
branch 14 taken 100% (fallthrough)
branch 15 taken 0%
        1:  389:          call ansyes(tname)
call    0 returned 100%
        -:  390:      else
    #####:  391:          call ansno(tname)
call    0 never executed
        -:  392:      endif 
       1*:  393:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  394:
        1:  395:      end
        -:  396:
        -:  397:
        -:  398:C -----------------------------------------------------
        -:  399:
function sersum3_ called 0 returned 0% blocks executed 0%
    #####:  400:      subroutine sersum3(AR,N,M,K,NL,S)
        -:  401:      integer AR(N,M,K)
        -:  402:      integer S,NL
    #####:  403:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  404:        do j=1,M
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  405:          do ii=1,K
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  406:            AR(i,j,ii) = i+j+ii+NL
        -:  407:          enddo          
        -:  408:        enddo
        -:  409:      enddo
    #####:  410:      S=0
    #####:  411:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  412:        do j=1,M
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  413:          do ii=1,K
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  414:            s = s+ AR(i,j,ii)
        -:  415:          enddo
        -:  416:        enddo
        -:  417:      enddo
    #####:  418:      end   
        -:  419:      
function sersum3m_ called 1 returned 100% blocks executed 100%
        1:  420:      subroutine sersum3m(AR,N,M,K,NL,S)
        -:  421:      integer AR(N,M,K)
        -:  422:      integer S,NL
       17:  423:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  424:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
     2192:  425:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     2176:  426:            AR(i,j,ii) = i+j+ii+NL
        -:  427:          enddo 
        -:  428:        enddo         
        -:  429:      enddo     
        1:  430:      ni=N/2-1
        1:  431:      nj=M/2-1
        1:  432:      nii=K/2-1
        1:  433:      AR(ni,nj,nii)=N+M+K+1+NL
        1:  434:      ni=N/2
        1:  435:      nj=M/2
        1:  436:      nii=K/2
        1:  437:      AR(ni,nj,nii)=-(N+M+K+1+NL)
        1:  438:      S=0
       17:  439:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  440:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
     2192:  441:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     2176:  442:            s = s+ AR(i,j,ii)
        -:  443:          enddo
        -:  444:        enddo
        -:  445:      enddo    
        1:  446:      end   
        -:  447:
function sersum3mr_ called 1 returned 100% blocks executed 100%
        1:  448:      subroutine sersum3mr(AR,N,M,K,NL,S)
        -:  449:      real AR(N,M,K)
        -:  450:      real S,NL
        9:  451:      do i=1,N
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       57:  452:        do j=1,M
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
      824:  453:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      816:  454:            AR(i,j,ii) = i+j+ii+NL
        -:  455:          enddo 
        -:  456:        enddo
        -:  457:      enddo 
        1:  458:      ni=N/2-1
        1:  459:      nj=M/2-1
        1:  460:      nii=K/2-1
        1:  461:      AR(ni,nj,nii)=N+M+K+1+NL
        1:  462:      ni=N/2
        1:  463:      nj=M/2
        1:  464:      nii=K/2
        1:  465:      AR(ni,nj,nii)=-(N+M+K+1+NL)
        1:  466:      S=0.
        9:  467:      do i=1,N
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       57:  468:        do j=1,M
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
      824:  469:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      816:  470:            s = s+ AR(i,j,ii)
        -:  471:          enddo
        -:  472:        enddo
        -:  473:      enddo
        1:  474:      end  
        -:  475:  
function serprod3_ called 1 returned 100% blocks executed 100%
        1:  476:      subroutine serprod3(AR,N,M,K,NL,P)
        -:  477:      integer AR(N,M,K)
        -:  478:      integer P,NL
       17:  479:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  480:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
     2192:  481:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     2176:  482:           AR(i,j,ii) = i+j+ii+NL
        -:  483:          enddo
        -:  484:        enddo
        -:  485:      enddo   
        1:  486:      P=1
       17:  487:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  488:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
     2192:  489:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     2176:  490:            P = P* AR(i,j,ii)
        -:  491:          enddo
        -:  492:        enddo
        -:  493:      enddo
        1:  494:      end   
        -:  495: 
function serprodr3_ called 0 returned 0% blocks executed 0%
    #####:  496:      subroutine serprodr3(AR,N,M,K,NL,P)
        -:  497:      real AR(N,M,K)
        -:  498:      real P,NL
    #####:  499:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  500:        do j=1,M
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  501:          do ii=1,K 
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  502:            AR(i,j,ii) = i+j+ii+NL
        -:  503:          enddo
        -:  504:        enddo
        -:  505:      enddo 
    #####:  506:      P=1.
    #####:  507:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  508:        do j=1,M
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  509:          do ii=1,K
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  510:            P = P* AR(i,j,ii)
        -:  511:          enddo
        -:  512:        enddo
        -:  513:      enddo
    #####:  514:      end
        -:  515:     
function serlog3_ called 1 returned 100% blocks executed 96%
        1:  516:      subroutine serlog3(AR,N,M,K,LAND,LOR,LEQV,LNEQV)
        -:  517:      logical AR(N,M,K)
        -:  518:      logical LAND,LOR,LEQV,LNEQV
       17:  519:      do  i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  520:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  521:          do ii=1,K,2
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    1024*:  522:            AR(i,j,ii) = .true.
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -:  523:          enddo         
        -:  524:        enddo
        -:  525:      enddo
       17:  526:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  527:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  528:          do ii=2,K,2
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    1024*:  529:            AR(i,j,ii)=.false.
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -:  530:          enddo
        -:  531:        enddo
        -:  532:      enddo 
        1:  533:      LAND=AR(1,1,1)
        1:  534:      LOR=AR(1,1,1)
        1:  535:      LEQV=AR(1,1,1)
        1:  536:      LNEQV=AR(1,1,1)
       17:  537:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  538:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
     2192:  539:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     2048:  540:            LAND = LAND .and. AR(i,j,ii)
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
    4224*:  541:            LOR = LOR .or.AR(i,j,ii)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  542:          enddo
        -:  543:        enddo
        -:  544:      enddo
       17:  545:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  546:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
     2192:  547:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     2176:  548:            LEQV = LEQV .eqv. AR(i,j,ii)
        -:  549:          enddo
        -:  550:        enddo
        -:  551:      enddo
       17:  552:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  553:        do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
     2192:  554:          do ii=1,K
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
     2176:  555:            LNEQV = LNEQV .neqv. AR(i,j,ii)
        -:  556:          enddo
        -:  557:        enddo
        -:  558:      enddo
        1:  559:      end   
        -:  560: 
function ansyes_ called 4 returned 100% blocks executed 100%
        4:  561:      subroutine ansyes(name)
        -:  562:      character*8 name
        4:  563:      print *,name,'  -  complete'
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        4:  564:      end
function ansno_ called 0 returned 0% blocks executed 0%
    #####:  565:      subroutine ansno(name)
        -:  566:      character*8 name
    #####:  567:      print *,name,'  -  ***error'
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  568:      end
