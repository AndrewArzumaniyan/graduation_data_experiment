        -:    0:Source:results/2d/realign22/realign22.f
        -:    0:Graph:./results\2d\realign22\realign22.gcno
        -:    0:Data:./results\2d\realign22\realign22.gcda
        -:    0:Runs:1
function MAIN__ called 1 returned 100% blocks executed 100%
        1:    1:      program REALIGN22
        -:    2:
        -:    3:c    Testing REALIGN directive        
        -:    4:
        1:    5:      print *,'===START OF realign22===================='
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:    6:C -------------------------------------------------
        -:    7:c 221 ALIGN arrB[i][j] WITH arrA[i][j] REALIGN arrB[i][j] WITH arrA[3*i-2][2*j+1]	
        1:    8:      call realign221
call    0 returned 100%
        -:    9:C -------------------------------------------------
        -:   10:c 222 ALIGN arrB[i][j] WITH arrA[j+1][i] REALIGN arrB[i][j] WITH arrA[i+4][j]	
        1:   11:      call realign222
call    0 returned 100%
        -:   12:C -------------------------------------------------
        -:   13:c 223 ALIGN arrB[i][*] WITH arrA[*][i]  REALIGN arrB[i][j] WITH arrA[i+4][j+4]	
        1:   14:      call realign223
call    0 returned 100%
        -:   15:C -------------------------------------------------
        -:   16:c 224 ALIGN arrB[*][*] WITH arrA[*][1]  REALIGN arrB[i][j] WITH arrA[i+4][j+4] shift along i and j
        1:   17:      call realign224
call    0 returned 100%
        -:   18:C -------------------------------------------------
        -:   19:c 225 ALIGN arrB[i][j] WITH arrA[i][j] REALIGN arrB[*][*] WITH arrA[*][2]	
        1:   20:      call realign225
call    0 returned 100%
        -:   21:C -------------------------------------------------
        -:   22:c 226 ALIGN arrB[i][j] WITH arrA[i][j] REALIGN arrB[i][j] WITH arrA[2*j+1][3*i-2]	
        1:   23:      call realign226
call    0 returned 100%
        -:   24:C -------------------------------------------------
        -:   25:C
        1:   26:      print *,'=== END OF realign22 ===================='
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   27:C
function main called 1 returned 100% blocks executed 100%
        1:   28:      end
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   29:C ----------------------------------------------------realign221
        -:   30:c 221 ALIGN arrB[i][j] WITH arrA[i][j] REALIGN arrB[i][j] WITH arrA[3*i-2][2*j+1]	
function realign221_ called 1 returned 100% blocks executed 84%
        1:   31:      subroutine realign221
        -:   32:      integer, parameter :: AN1=10,AN2=10,BN1=4,BN2=4,NL=1000,ER=10000
        -:   33:      integer :: erria=ER, errib=ER
        -:   34:      integer :: i,j,ia,ja,ib,jb
        -:   35:c     parameters for ALIGN arrB[i][j] WITH arrA[k1i * i + li][k2j * j + lj]                                                 
        -:   36:      integer, parameter ::  k1i=1,k2i=0,li=0,k1j=0,k2j=1,lj=0
        -:   37:c     parameters for REALIGN arrB[i][j] WITH arrA[kr1i * i + lri][kr2j * j + lrj]                                                 
        -:   38:      integer, parameter ::  kr1i=3,kr2i=0,lri=-2,kr1j=0,kr2j=2,lrj=1
        1:   39:      integer, allocatable :: A2(:,:),B2(:,:)
        -:   40:      character(10) ::  tname = 'realign221'
        -:   41:               
        -:   42:!dvm$ distribute A2(BLOCK,BLOCK)   
        -:   43:!dvm$ ALIGN B2(i,j) WITH A2(k1i * i + li,k2j * j + lj)
        -:   44:!dvm$ DYNAMIC B2
        -:   45:
       1*:   46:      allocate (A2(AN1,AN2),B2(BN1,BN2))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:   47:       
        -:   48:!dvm$ region
        -:   49:!dvm$ parallel (i,j) on B2(i,j)
        5:   50:      do i=1,BN1
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       21:   51:          do j=1,BN2
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       20:   52:            B2(i,j) = 0     
        -:   53:          enddo 
        -:   54:      enddo
        -:   55:
        -:   56:!dvm$ parallel (i,j) on A2(i,j), private(ib,jb)
       11:   57:      do i=1,AN1
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
      111:   58:          do j=1,AN2
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
      100:   59:             A2(i,j) = i*NL+j
        -:   60:             if (((i-li) .eq.(((i-li)/k1i) * k1i)) .and.
        -:   61:     *          ((j-lj) .eq.(((j-lj)/k2j) *k2j)) .and.
        -:   62:     *          (((i-li)/k1i) .gt. 0)  .and.
        -:   63:     *          (((j-lj)/k2j) .gt. 0)  .and.
      100:   64:     *          (((i-li)/k1i) .le. BN1)  .and.
branch  0 taken 16% (fallthrough)
branch  1 taken 84%
       10:   65:     *          (((j-lj)/k2j) .le. BN2))  then 
       16:   66:                ib = (i-li)/k1i
       16:   67:                jb = (j-lj)/k2j  
       16:   68:                B2(ib,jb) = ib*NL+jb
        -:   69:             endif 
        -:   70:          enddo 
        -:   71:      enddo
        -:   72:!dvm$ end region
        -:   73:
        -:   74:!dvm$ REALIGN B2(i,j) WITH A2(kr1i * i + lri,kr2j * j + lrj)
        -:   75:
        -:   76:!dvm$ actual(erria,errib)
        -:   77:!dvm$ region in(A2,B2), out(A2,B2)
        -:   78:!dvm$ parallel (i,j) on B2(i,j), private(ia,ja), 
        -:   79:!dvm$*       reduction(min(erria),min(errib))
        5:   80:      do i=1,BN1
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       21:   81:          do j=1,BN2
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       16:   82:            if (B2(i,j) /= (i*NL+j)) then     
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   83:               errib = min(errib,i*NL/10+j)
        -:   84:            endif 
       16:   85:            ia=kr1i * i + lri
       16:   86:            ja=kr2j * j + lrj
       20:   87:            if (A2(ia,ja) /= (ia*NL+ja)) then     
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   88:               erria = min(erria,i*NL/10+j)
        -:   89:            endif 
        -:   90:          enddo 
        -:   91:      enddo
        -:   92:!dvm$ end region
        -:   93:  
        -:   94:!dvm$ get_actual(erria,errib)
        1:   95:      if ((erria == ER) .and. (errib == ER)) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:   96:          call ansyes(tname)
call    0 returned 100%
        -:   97:      else
    #####:   98:          call ansno(tname)
call    0 never executed
        -:   99:      endif 
        -:  100:
       1*:  101:      deallocate (B2,A2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  102:
        1:  103:      end
        -:  104:
        -:  105:C ----------------------------------------------------realign222
        -:  106:c 222 ALIGN arrB[i][j] WITH arrA[j+1][i] REALIGN arrB[i][j] WITH arrA[i+4][j]	
function realign222_ called 1 returned 100% blocks executed 84%
        1:  107:      subroutine realign222
        -:  108:      integer, parameter :: AN1=8,AN2=8,BN1=4,BN2=4,NL=1000,ER=10000
        -:  109:      integer :: erria=ER, errib=ER
        -:  110:      integer :: i,j,ia,ja,ib,jb
        -:  111:c     parameters for ALIGN arrB[i][j] WITH arrA[k2i * j + li][k1j * i + lj]                                                 
        -:  112:      integer, parameter ::  k1i=0,k2i=1,li=1,k1j=1,k2j=0,lj=0
        -:  113:c     parameters for REALIGN arrB[i][j] WITH arrA[kr1i * i + lri][kr2j * j + lrj]                                                 
        -:  114:      integer, parameter ::  kr1i=1,kr2i=0,lri=0,kr1j=0,kr2j=1,lrj=0
        1:  115:      integer, allocatable :: A2(:,:),B2(:,:)
        -:  116:      character(10) ::  tname = 'realign222'
        -:  117:               
        -:  118:!dvm$ distribute A2(BLOCK,BLOCK)   
        -:  119:!dvm$ ALIGN B2(i,j) WITH A2(k2i * j + li,k1j * i + lj)
        -:  120:!dvm$ DYNAMIC B2
        -:  121:
       1*:  122:      allocate (A2(AN1,AN2),B2(BN1,BN2))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  123:       
        -:  124:!dvm$ region
        -:  125:!dvm$ parallel (i,j) on B2(i,j)
        5:  126:      do i=1,BN1
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       21:  127:          do j=1,BN2
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       20:  128:            B2(i,j) = 1     
        -:  129:          enddo 
        -:  130:      enddo
        -:  131:
        -:  132:!dvm$ parallel (i,j) on A2(i,j), private(ib,jb)
        9:  133:      do i=1,AN1
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       73:  134:          do j=1,AN2
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       64:  135:             A2(i,j) = (i*NL+j)*2
        -:  136:             if (((i-li) .eq.(((i-li)/k2i) * k2i)) .and.
        -:  137:     *          ((j-lj) .eq.(((j-lj)/k1j) *k1j)) .and.
        -:  138:     *          (((i-li)/k2i) .gt. 0)  .and.
        -:  139:     *          (((j-lj)/k1j) .gt. 0)  .and.
       64:  140:     *          (((i-li)/k2i) .le. BN2)  .and.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
branch  2 taken 29% (fallthrough)
branch  3 taken 71%
        8:  141:     *          (((j-lj)/k1j) .le. BN1))  then 
       16:  142:                ib = (j-lj)/k1j
       16:  143:                jb = (i-li)/k2i  
       16:  144:                B2(ib,jb) = B2(ib,jb) + ib*NL+jb
        -:  145:             endif 
        -:  146:          enddo 
        -:  147:      enddo
        -:  148:!dvm$ end region
        -:  149:
        -:  150:!dvm$ REALIGN B2(i,j) WITH A2(kr1i * i + lri,kr2j * j + lrj)
        -:  151:
        -:  152:!dvm$ actual(erria,errib)
        -:  153:!dvm$ region 
        -:  154:!dvm$ parallel (i,j) on B2(i,j),
        -:  155:!dvm$*       reduction(min(erria),min(errib)),
        -:  156:!dvm$*       private(ia,ja) 
        -:  157:
        5:  158:      do i=1,BN1
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       21:  159:          do j=1,BN2
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       16:  160:            if (B2(i,j) /= (i*NL+j+1)) then     
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  161:               errib = min(errib,i*NL/10+j)
        -:  162:            endif 
       16:  163:            ia=kr1i * i + lri
       16:  164:            ja=kr2j * j + lrj
       20:  165:            if (A2(ia,ja) /= (ia*NL+ja)*2) then     
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  166:               erria = min(erria,i*NL/10+j)
        -:  167:            endif 
        -:  168:          enddo 
        -:  169:      enddo
        -:  170:!dvm$ end region
        -:  171:  
        -:  172:!dvm$ get_actual(erria,eriib)
        1:  173:      if ((erria == ER) .and. (errib == ER)) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  174:          call ansyes(tname)
call    0 returned 100%
        -:  175:      else
    #####:  176:          call ansno(tname)
call    0 never executed
        -:  177:      endif 
        -:  178:
       1*:  179:      deallocate (B2,A2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  180:
        1:  181:      end
        -:  182:
        -:  183:C ----------------------------------------------------realign223
        -:  184:c 223 ALIGN arrB[i][*] WITH arrA[*][i]  REALIGN arrB[i][j] WITH arrA[i+4][j+4]	
function realign223_ called 1 returned 100% blocks executed 84%
        1:  185:      subroutine realign223
        -:  186:      integer, parameter :: AN1=10,AN2=10,BN1=4,BN2=4,NL=1000,ER=10000
        -:  187:      integer :: erria=ER, errib=ER
        -:  188:      integer :: i,j,ia,ja,ib,jb
        -:  189:c     parameters for ALIGN arrB[i][*] WITH arrA[*][k1j*i + lj]                                                 
        -:  190:      integer, parameter ::  k1i=0,k2i=0,li=0,k1j=1,k2j=0,lj=0
        -:  191:c     parameters for REALIGN arrB[i][j] WITH arrA[kr1i * i + lri][kr2j * j + lrj]                                                 
        -:  192:      integer, parameter ::  kr1i=1,kr2i=0,lri=4,kr1j=0,kr2j=1,lrj=4
        1:  193:      integer, allocatable :: A2(:,:),B2(:,:)
        -:  194:      character(10) ::  tname = 'realign223'
        -:  195:               
        -:  196:!dvm$ distribute A2(BLOCK,BLOCK)   
        -:  197:!dvm$ ALIGN B2(i,*) WITH A2(*,k1j * i + lj)
        -:  198:!dvm$ DYNAMIC B2
        -:  199:
       1*:  200:      allocate (A2(AN1,AN2),B2(BN1,BN2))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  201:       
       21:  202:      B2 = 0     
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
branch  2 taken 80% (fallthrough)
branch  3 taken 20%
        -:  203:
        -:  204:!dvm$ region
        -:  205:!dvm$ parallel (i,j) on A2(i,j), private(ib,jb,k)
       11:  206:      do i=1,AN1
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
      111:  207:          do j=1,AN2
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
      100:  208:             A2(i,j) = i*NL+j
      510:  209:             do k=1,BN2
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -:  210:              if (
        -:  211:     *          ((j-lj) .eq.(((j-lj)/k1j) *k1j)) .and.
      400:  212:     *          (((j-lj)/k1j) .gt. 0)  .and.
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
        -:  213:     *          (((j-lj)/k1j) .le. BN1)
      100:  214:     *          )  then 
      160:  215:                ib = ((j-lj)/k1j)
      160:  216:                jb = k 
        -:  217:!               B2(ib,jb) = B2(ib,jb) + ib*NL+jb
      160:  218:                B2(ib,jb) = ib*NL+jb+5
        -:  219:              endif 
        -:  220:             enddo
        -:  221:          enddo 
        -:  222:      enddo
        -:  223:!dvm$ end region
        -:  224:
        -:  225:!dvm$ REALIGN B2(i,j) WITH A2(kr1i * i + lri,kr2j * j + lrj)
        -:  226:
        -:  227:!dvm$ actual(erria,errib)
        -:  228:!dvm$ region in(A2,B2), local(A2,B2)
        -:  229:!dvm$ parallel (i,j) on B2(i,j), private(ia,ja),
        -:  230:!dvm$*       reduction(min(erria),min(errib))
        5:  231:      do i=1,BN1
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       21:  232:          do j=1,BN2
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       16:  233:            if (B2(i,j) /= (i*NL+j+5)) then     
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  234:               errib = min(errib,i*NL/10+j)
        -:  235:            endif 
       16:  236:            ia=kr1i * i + lri
       16:  237:            ja=kr2j * j + lrj
       20:  238:            if (A2(ia,ja) /= (ia*NL+ja)) then     
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  239:               erria = min(erria,i*NL/10+j)
        -:  240:            endif 
        -:  241:          enddo 
        -:  242:      enddo
        -:  243:!dvm$ end region
        -:  244:     
        -:  245:!dvm$ get_actual(erria,errib)
        1:  246:      if ((erria == ER) .and. (errib == ER)) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  247:          call ansyes(tname)
call    0 returned 100%
        -:  248:      else
    #####:  249:          call ansno(tname)
call    0 never executed
        -:  250:!         print *,erria, errib
        -:  251:      endif 
        -:  252:
       1*:  253:      deallocate (B2,A2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  254:
        1:  255:      end
        -:  256:
        -:  257:C ----------------------------------------------------realign224
        -:  258:c 224 ALIGN arrB[*][*] WITH arrA[*][1]  REALIGN arrB[i][j] WITH arrA[i+4][j+4] 
function realign224_ called 1 returned 100% blocks executed 85%
        1:  259:      subroutine realign224
        -:  260:      integer, parameter :: AN1=10,AN2=10,BN1=4,BN2=4,NL=1000,ER=10000
        -:  261:      integer :: erria=ER, errib=ER
        -:  262:      integer :: i,j,ia,ja,ib,jb
        -:  263:c     parameters for ALIGN arrB[*][*] WITH arrA[*][lj]                                                 
        -:  264:      integer, parameter ::  k1i=0,k2i=0,li=0,k1j=0,k2j=0,lj=1
        -:  265:c     parameters for REALIGN arrB[i][j] WITH arrA[kr1i * i + lri][kr2j * j + lrj]                                                 
        -:  266:      integer, parameter ::  kr1i=1,kr2i=0,lri=4,kr1j=0,kr2j=1,lrj=4
        1:  267:      integer, allocatable :: A2(:,:),B2(:,:)
        -:  268:      character(10) ::  tname = 'realign224'
        -:  269:               
        -:  270:!dvm$ distribute A2(BLOCK,BLOCK)   
        -:  271:!dvm$ ALIGN B2(*,*) WITH A2(*,lj)
        -:  272:!dvm$ DYNAMIC B2
        -:  273:
       1*:  274:      allocate (A2(AN1,AN2),B2(BN1,BN2))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  275:
       21:  276:      B2 = 0
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
branch  2 taken 80% (fallthrough)
branch  3 taken 20%
        -:  277: 
        -:  278:!dvm$ region
        -:  279:!dvm$ parallel (i,j) on A2(i,j), private(ib,jb,k,n)
       11:  280:      do i=1,AN1
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
      111:  281:          do j=1,AN2
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
      100:  282:             A2(i,j) = i*NL+j+3
      110:  283:             if (j == (lj)) then
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
       50:  284:                do k=1,BN1
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
      210:  285:                    do n=1,BN2
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
      160:  286:                         ib = k
      160:  287:                         jb = n 
        -:  288:!                        B2(ib,jb) = B2(ib,jb) + (ib*NL+jb)*2
      200:  289:                         B2(ib,jb) = (ib*NL+jb)*2
        -:  290:                    enddo
        -:  291:                enddo
        -:  292:            endif
        -:  293:          enddo 
        -:  294:       enddo
        -:  295:!dvm$ end region
        -:  296:
        -:  297:!dvm$ REALIGN B2(i,j) WITH A2(kr1i * i + lri,kr2j * j + lrj)
        -:  298:
        -:  299:!dvm$ actual(erria,errib)
        -:  300:!dvm$ region
        -:  301:!dvm$ parallel (i,j) on B2(i,j), private(ia,ja),
        -:  302:!dvm$*       reduction(min(erria),min(errib))
        5:  303:      do i=1,BN1
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       21:  304:          do j=1,BN2
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       16:  305:            if (B2(i,j) /= (i*NL+j)*2) then     
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  306:               errib = min(errib,i*NL/10+j)
        -:  307:            endif 
       16:  308:            ia=kr1i * i + lri
       16:  309:            ja=kr2j * j + lrj
       20:  310:            if (A2(ia,ja) /= (ia*NL+ja+3)) then     
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  311:               erria = min(erria,i*NL/10+j)
        -:  312:            endif 
        -:  313:          enddo 
        -:  314:      enddo
        -:  315:!dvm$ end region
        -:  316:     
        -:  317:!dvm$ get_actual(erria,errib)
        1:  318:      if ((erria == ER) .and. (errib == ER)) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  319:          call ansyes(tname)
call    0 returned 100%
        -:  320:      else
    #####:  321:          call ansno(tname)
call    0 never executed
        -:  322:!         print *,erria, errib
        -:  323:      endif 
        -:  324:
       1*:  325:      deallocate (B2,A2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  326:
        1:  327:      end
        -:  328:
        -:  329:C ----------------------------------------------------realign225
        -:  330:c 225	ALIGN arrB[i][j] WITH arrA[i][j] REALIGN arrB[*][*] WITH arrA[*][2]	
function realign225_ called 1 returned 100% blocks executed 85%
        1:  331:      subroutine realign225
        -:  332:      integer, parameter :: AN1=10,AN2=10,BN1=4,BN2=4,NL=1000,ER=10000
        -:  333:      integer :: erria=ER, errib=ER
        -:  334:      integer :: i,j,ia,ja,ib,jb
        -:  335:c     parameters for ALIGN arrB[i][j] WITH arrA[k1i * i + li][k2j * j + lj]                                                 
        -:  336:      integer, parameter ::  k1i=1,k2i=0,li=0,k1j=0,k2j=1,lj=0
        -:  337:c     parameters for REALIGN arrB[*][*] WITH arrA[*][lrj]                                                 
        -:  338:      integer, parameter ::  kr1i=0,kr2i=0,lri=0,kr1j=0,kr2j=0,lrj=2
        1:  339:      integer, allocatable :: A2(:,:),B2(:,:)
        -:  340:      character(10) ::  tname = 'realign225'
        -:  341:               
        -:  342:!dvm$ distribute A2(BLOCK,BLOCK)   
        -:  343:!dvm$ ALIGN B2(i,j) WITH A2(k1i * i + li,k2j * j + lj)
        -:  344:!dvm$ DYNAMIC B2
        -:  345:
       1*:  346:      allocate (A2(AN1,AN2),B2(BN1,BN2))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  347:       
        -:  348:!dvm$ region
        -:  349:!dvm$ parallel (i,j) on B2(i,j)
        5:  350:      do i=1,BN1
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       21:  351:          do j=1,BN2
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       20:  352:            B2(i,j) = 0     
        -:  353:          enddo 
        -:  354:      enddo
        -:  355:
        -:  356:!dvm$ parallel (i,j) on A2(i,j), private(ib,jb)
       11:  357:      do i=1,AN1
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
      111:  358:          do j=1,AN2
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
      100:  359:             A2(i,j) = i*NL+j
        -:  360:             if (((i-li) .eq.(((i-li)/k1i) * k1i)) .and.
        -:  361:     *          ((j-lj) .eq.(((j-lj)/k2j) *k2j)) .and.
        -:  362:     *          (((i-li)/k1i) .gt. 0)  .and.
        -:  363:     *          (((j-lj)/k2j) .gt. 0)  .and.
      100:  364:     *          (((i-li)/k1i) .le. BN1)  .and.
branch  0 taken 16% (fallthrough)
branch  1 taken 84%
       10:  365:     *          (((j-lj)/k2j) .le. BN2))  then 
       16:  366:                ib = (i-li)/k1i
       16:  367:                jb = (j-lj)/k2j  
       16:  368:                B2(ib,jb) = ib*NL+jb
        -:  369:             endif 
        -:  370:          enddo 
        -:  371:      enddo
        -:  372:!dvm$ end region
        -:  373:
        -:  374:!dvm$ REALIGN B2(*,*) WITH A2(*,lrj)
        -:  375:
        -:  376:!dvm$ actual(errib)
        -:  377:!dvm$ region
        -:  378:!dvm$ parallel (i,j) on B2(i,j), reduction( min( errib ) )
        5:  379:      do i=1,BN1
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       21:  380:          do j=1,BN2
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       20:  381:            if (B2(i,j) /= (i*NL+j)) then     
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  382:               errib = min(errib,i*NL/10+j)
        -:  383:            endif 
        -:  384:          enddo 
        -:  385:      enddo
        -:  386:!dvm$ end region
        -:  387:  
        -:  388:!dvm$ get_actual(errib)
        1:  389:      if (errib == ER) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  390:          call ansyes(tname)
call    0 returned 100%
        -:  391:      else
    #####:  392:          call ansno(tname)
call    0 never executed
        -:  393:      endif 
        -:  394:
       1*:  395:      deallocate (B2,A2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  396:
        1:  397:      end
        -:  398:C ----------------------------------------------------realign226
        -:  399:c 226 ALIGN arrB[i][j] WITH arrA[i][j] REALIGN arrB[i][j] WITH arrA[2*j+1][3*i-2]	
function realign226_ called 1 returned 100% blocks executed 84%
        1:  400:      subroutine realign226
        -:  401:      integer, parameter :: AN1=16,AN2=18,BN1=6,BN2=4,NL=1000,ER=10000
        -:  402:      integer :: erria=ER, errib=ER
        -:  403:      integer :: i,j,ia,ja,ib,jb
        -:  404:c     parameters for ALIGN arrB[i][j] WITH arrA[k1i * i + li][k2j * j + lj]                                                 
        -:  405:      integer, parameter ::  k1i=1,li=0,k2j=1,lj=0
        -:  406:c     parameters for REALIGN arrB[i][j] WITH arrA[kr1i * i + lri][kr2j * j + lrj]                                                 
        -:  407:      integer, parameter ::  kr1i=3,lri=-2,kr2j=2,lrj=1
        1:  408:      integer, allocatable :: A2(:,:),B2(:,:)
        -:  409:      character(10) ::  tname = 'realign226'
        -:  410:               
        -:  411:!dvm$ distribute A2(BLOCK,BLOCK)   
        -:  412:!dvm$ ALIGN B2(i,j) WITH A2(k1i * i + li,k2j * j + lj)
        -:  413:!dvm$ DYNAMIC B2
        -:  414:
       1*:  415:      allocate (A2(AN1,AN2),B2(BN1,BN2))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  416:       
        -:  417:!dvm$ region
        -:  418:!dvm$ parallel (i,j) on B2(i,j)
        7:  419:      do i=1,BN1
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
       31:  420:          do j=1,BN2
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       30:  421:            B2(i,j) = 0     
        -:  422:          enddo 
        -:  423:      enddo
        -:  424:
        -:  425:!dvm$ parallel (i,j) on A2(i,j), private(ib,jb)
       17:  426:      do i=1,AN1
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      305:  427:          do j=1,AN2
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
      288:  428:             A2(i,j) = (i*NL+j) * 3
        -:  429:             if (((i-li) .eq.(((i-li)/k1i) * k1i)) .and.
        -:  430:     *          ((j-lj) .eq.(((j-lj)/k2j) *k2j)) .and.
        -:  431:     *          (((i-li)/k1i) .gt. 0)  .and.
        -:  432:     *          (((j-lj)/k2j) .gt. 0)  .and.
      288:  433:     *          (((i-li)/k1i) .le. BN1)  .and.
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
       16:  434:     *          (((j-lj)/k2j) .le. BN2))  then 
       24:  435:                ib = (i-li)/k1i
       24:  436:                jb = (j-lj)/k2j  
       24:  437:                B2(ib,jb) = ib*NL+jb
        -:  438:             endif 
        -:  439:          enddo 
        -:  440:      enddo
        -:  441:!dvm$ end region
        -:  442:
        -:  443:!dvm$ REALIGN B2(i,j) WITH A2(kr2j * j + lrj,kr1i * i + lri)
        -:  444:
        -:  445:!dvm$ actual(erria,errib)
        -:  446:!dvm$ region inlocal(A2,B2)
        -:  447:!dvm$ parallel (i,j) on B2(i,j), private(ia,ja),
        -:  448:!dvm$*       reduction(min(erria),min(errib))
        7:  449:      do i=1,BN1
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
       31:  450:          do j=1,BN2
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
       24:  451:            if (B2(i,j) /= (i*NL+j)) then     
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  452:               errib = min(errib,i*NL/10+j)
        -:  453:            endif 
       24:  454:            ia=kr2j * j + lrj
       24:  455:            ja=kr1i * i + lri
       30:  456:            if (A2(ia,ja) /= (ia*NL+ja)*3) then     
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  457:               erria = min(erria,i*NL/10+j)
        -:  458:            endif 
        -:  459:          enddo 
        -:  460:      enddo 
        -:  461:!dvm$ end region
        -:  462:
        -:  463:!dvm$ get_actual(erria,errib)
        1:  464:      if ((erria == ER) .and. (errib == ER)) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  465:          call ansyes(tname)
call    0 returned 100%
        -:  466:      else
    #####:  467:          call ansno(tname)
call    0 never executed
        -:  468:      endif 
        -:  469:
       1*:  470:      deallocate (B2,A2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  471:
        1:  472:      end
        -:  473:
        -:  474:C ---------------------------------------------------
function ansyes_ called 6 returned 100% blocks executed 100%
        6:  475:      subroutine ansyes(name)
        -:  476:      character(*) name
        6:  477:      print *,name,'  -  complete'
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        6:  478:      end
function ansno_ called 0 returned 0% blocks executed 0%
    #####:  479:      subroutine ansno(name)
        -:  480:      character(*) name
    #####:  481:      print *,name,'  -  ***error'
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  482:      end
        -:  483:   
