        -:    0:Source:results/2d/red21/red21.f
        -:    0:Graph:./results\2d\red21\red21.gcno
        -:    0:Data:./results\2d\red21\red21.gcda
        -:    0:Runs:1
function MAIN__ called 1 returned 100% blocks executed 100%
        1:    1:      program RED21
        -:    2:
        -:    3:c    TESTING OF THE REDUCTION CLAUSE .       
        -:    4:c    REDUCTION OPERATION : SUM,PRODUCT,MAX,MIN,AND,OR, EQV,
        -:    5:C    NEQV,MAXLOC,MINLOC AND THEIR COMBINATION ARE EXECUTED
        -:    6:c    FOR DISTRIBUTED ARRAY A(N,M). 
        -:    7:
        1:    8:      print *,'===START OF RED21======================='
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:    9:C --------------------------------------------------
        1:   10:      call red2101
call    0 returned 100%
        -:   11:C --------------------------------------------------
        1:   12:      call red2102
call    0 returned 100%
        -:   13:C --------------------------------------------------
        1:   14:      call red2103
call    0 returned 100%
        -:   15:C -------------------------------------------------
        1:   16:      call red2104
call    0 returned 100%
        -:   17:C -------------------------------------------------
        1:   18:      call red2105
call    0 returned 100%
        -:   19:C -------------------------------------------------
        1:   20:      call red2106
call    0 returned 100%
        -:   21:C --------------------------------------------------
        1:   22:      call red2107
call    0 returned 100%
        -:   23:C --------------------------------------------------
        1:   24:      call red2108
call    0 returned 100%
        -:   25:C --------------------------------------------------
        1:   26:      call red2109
call    0 returned 100%
        -:   27:C -------------------------------------------------
        1:   28:      call red2110
call    0 returned 100%
        -:   29:C -------------------------------------------------
        1:   30:      call red2111
call    0 returned 100%
        -:   31:C -------------------------------------------------
        1:   32:      call red2112
call    0 returned 100%
        -:   33:C --------------------------------------------------
        1:   34:      call red2113
call    0 returned 100%
        -:   35:C --------------------------------------------------
        1:   36:      call red2114
call    0 returned 100%
        -:   37:C --------------------------------------------------
        -:   38:C
        -:   39:C
        1:   40:      print *,'=== END OF RED21 ========================= '    
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
function main called 1 returned 100% blocks executed 100%
        1:   41:      end
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   42:
        -:   43:C ----------------------------------------------------RED2101
function red2101_ called 1 returned 100% blocks executed 82%
        1:   44:      subroutine RED2101
        -:   45:      integer, parameter :: N = 16,M=8,NL=1000
        -:   46:      character*7 tname
        1:   47:      integer, allocatable :: A(:,:),C(:,:)
        -:   48:      integer isum1,isumt1 
        -:   49:                 
        -:   50:!dvm$ distribute A(BLOCK,BLOCK)    
        -:   51:
        1:   52:      tname='RED2101'
       1*:   53:      allocate (A(N,M),C(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:   54:      NNL=NL 
        1:   55:      NN=N
        1:   56:      MM=M
        1:   57:      call sersum2(C,NN,MM,NNL,isum1)
        1:   58:      isumt1 = 0
        -:   59:
        -:   60:!dvm$ actual(isumt1)
        -:   61:!dvm$ region local(A)
        -:   62:!dvm$ parallel (i,j) on A(i,j)
       17:   63:      do i=1,N
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
      145:   64:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:   65:           A(i,j) = i+j+NL
        -:   66:         enddo
        -:   67:      enddo
        -:   68:  
        -:   69:!dvm$ parallel (i,j) on A(i,j), reduction( sum( isumt1 ) )
       17:   70:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:   71:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:   72:           isumt1 = isumt1+A(i,j)
        -:   73:         enddo
        -:   74:      enddo
        -:   75:!dvm$ end region   
        -:   76:!dvm$ get_actual(isumt1) 
        -:   77:     
        1:   78:      if (isum1 .eq.isumt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   79:          call ansyes(tname)
call    0 returned 100%
        -:   80:      else
    #####:   81:          call ansno(tname)
call    0 never executed
        -:   82:      endif 
       1*:   83:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:   84:
        1:   85:      end
        -:   86:C -----------------------------------------------------RED2102
function red2102_ called 1 returned 100% blocks executed 82%
        1:   87:      subroutine RED2102
        -:   88:      integer, parameter :: N = 16,M=8,NL=1
        -:   89:      character*7 tname
        1:   90:      integer, allocatable :: A(:,:),C(:,:)
        -:   91:      integer iprod1,iprodt1 
        -:   92:      
        -:   93:!dvm$ distribute A(BLOCK,BLOCK)    
        -:   94:      
        1:   95:      tname='RED2102'
       1*:   96:      allocate (A(N,M),C(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:   97:      NNL=NL
        1:   98:      NN=N
        1:   99:      MM=M
        1:  100:      call serprod2(C,NN,MM,NNL,iprod1)
        1:  101:      iprodt1 = 1
        -:  102:
        -:  103:!dvm$ actual(iprodt1)
        -:  104:!dvm$ region local(A)
        -:  105:!dvm$ parallel (i,j) on A(i,j)
       17:  106:      do i=1,N
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
      145:  107:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  108:           A(i,j) = i+j+NL
        -:  109:         enddo
        -:  110:      enddo
        -:  111:  
        -:  112:!dvm$ parallel (i,j) on A(i,j), reduction( product( iprodt1 ) )
       17:  113:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  114:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  115:           iprodt1 = iprodt1*A(i,j)
        -:  116:         enddo
        -:  117:      enddo
        -:  118:!dvm$ end region   
        -:  119:!dvm$ get_actual(iprodt1) 
        -:  120: 
        1:  121:      if (iprod1 .eq.iprodt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  122:          call ansyes(tname)
call    0 returned 100%
        -:  123:      else
    #####:  124:          call ansno(tname)
call    0 never executed
        -:  125:      endif 
       1*:  126:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  127: 
        1:  128:      end
        -:  129:C ----------------------------------------------------RED2103
function red2103_ called 1 returned 100% blocks executed 91%
        1:  130:      subroutine RED2103
        -:  131:      integer, parameter :: N = 16,M=8,NL=1000
        -:  132:      character*7 tname
        1:  133:      integer, allocatable :: A(:,:)
        -:  134:      integer imax1,imaxt1 ,ni,imin,nj
        -:  135:                       
        -:  136:!dvm$ distribute A(BLOCK,BLOCK) 
        -:  137:
        1:  138:      tname='RED2103'
       1*:  139:      allocate (A(N,M))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 never executed
        -:  140:     
        -:  141:!dvm$ parallel (i,j) on A(i,j)
       17:  142:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  143:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  144:           A(i,j) = i+j+NL
        -:  145:         enddo
        -:  146:      enddo
        1:  147:      ni=N/2
        1:  148:      nj=M/2
        1:  149:      A(ni,nj)=N+M+1+NL
        1:  150:      imax1=N+M+1+NL
        -:  151:
        -:  152:!dvm$ remote_access (A(1,1))
        1:  153:      imaxt1=A(1,1)  
        -:  154:
        -:  155:!dvm$ actual(imaxt1,A)
        -:  156:!dvm$ region
        -:  157:!dvm$ parallel (i,j) on A(i,j), reduction( max( imaxt1 ) )
       17:  158:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  159:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  160:           if (A(i,j).GT.imaxt1) imaxt1=A(i,j)
        -:  161:         enddo
        -:  162:      enddo
        -:  163:!dvm$ end region   
        -:  164:!dvm$ get_actual(imaxt1) 
        -:  165:
        1:  166:      if (imax1 .eq.imaxt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  167:          call ansyes(tname)
call    0 returned 100%
        -:  168:      else
    #####:  169:          call ansno(tname)
call    0 never executed
        -:  170:      endif 
        1:  171:      deallocate (A)
        -:  172:      
        1:  173:      end
        -:  174:    
        -:  175:C ----------------------------------------------------RED2104
function red2104_ called 1 returned 100% blocks executed 85%
        1:  176:      subroutine RED2104
        -:  177:      integer, parameter :: N = 16,M=8,NL=1000
        -:  178:      character*7 tname
        1:  179:      integer, allocatable :: A(:,:),C(:,:)
        -:  180:      integer imax1,imaxt1 ,ni,imin,nj
        -:  181:                       
        -:  182:!dvm$ distribute A(BLOCK,BLOCK)
        -:  183:
        1:  184:      tname='RED2104'
       1*:  185:      allocate (A(N,M),C(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  186:
        -:  187:!dvm$ parallel (i,j) on A(i,j)
       17:  188:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  189:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  190:           A(i,j) = i+j+NL
        -:  191:         enddo
        -:  192:      enddo
        -:  193:  
        1:  194:      ni=N/2
        1:  195:      nj=M/2 
        1:  196:      A(ni,nj)=-(N+M+1+NL)
        1:  197:      imin1=-(N+M+1+NL)
        -:  198:
        -:  199:!dvm$ remote_access (A(1,1))      
        1:  200:      imint1=A(1,1)
        -:  201:
        -:  202:!dvm$ actual(imint1)
        -:  203:!dvm$ region
        -:  204:!dvm$ parallel (i,j) on A(i,j), reduction( min( imint1 ) )
       16:  205:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      136:  206:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      135:  207:           if (A(i,j).LT.imint1) imint1=A(i,j)
        -:  208:         enddo
        -:  209:      enddo
        -:  210:!dvm$ end region   
        -:  211:!dvm$ get_actual(imint1) 
        -:  212:
        1:  213:      if (imin1 .eq.imint1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  214:          call ansyes(tname)
call    0 returned 100%
        -:  215:      else
    #####:  216:          call ansno(tname)
call    0 never executed
        -:  217:      endif 
       1*:  218:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  219: 
        1:  220:      end
        -:  221:C ----------------------------------------------------RED2105
function red2105_ called 1 returned 100% blocks executed 85%
        1:  222:      subroutine RED2105
        -:  223:      integer, parameter :: N = 16,M=8
        -:  224:      real, parameter :: NL=1000.
        -:  225:      character*7 tname
        1:  226:      real, allocatable :: A(:,:),C(:,:)
        -:  227:      integer ni
        -:  228:      real imax1,imaxt1                  
        -:  229:!dvm$ distribute A(BLOCK,BLOCK)
        -:  230:
        1:  231:      tname='RED2105'
       1*:  232:      allocate (A(N,M),C(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  233:     
        -:  234:!dvm$ parallel (i,j) on A(i,j)
       17:  235:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  236:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  237:           A(i,j) = i+j+NL
        -:  238:         enddo
        -:  239:      enddo
        1:  240:      ni=N/2
        1:  241:      nj=M/2
        1:  242:      A(ni,nj)=N+M+1.+NL
        1:  243:      imax1=N+M+1.+NL
        -:  244:
        -:  245:!dvm$ remote_access (A(1,1))
        1:  246:      imaxt1=A(1,1)  
        -:  247:
        -:  248:!dvm$ actual(imaxt1)
        -:  249:!dvm$ region
        -:  250:!dvm$ parallel (i,j) on A(i,j), reduction( max( imaxt1 ) )
       16:  251:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      136:  252:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      135:  253:           if (A(i,j).GT.imaxt1) imaxt1=A(i,j)
        -:  254:         enddo
        -:  255:      enddo
        -:  256:!dvm$ end region   
        -:  257:!dvm$ get_actual(imaxt1) 
        -:  258:
        1:  259:      if (imax1 .eq.imaxt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  260:          call ansyes(tname)
call    0 returned 100%
        -:  261:      else
    #####:  262:          call ansno(tname)
call    0 never executed
        -:  263:      endif 
       1*:  264:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  265:      
        1:  266:      end
        -:  267:                    
        -:  268:C -----------------------------------------------------RED2106
function red2106_ called 1 returned 100% blocks executed 84%
        1:  269:      subroutine RED2106
        -:  270:      integer, parameter :: N = 8,M=6
        -:  271:      real, parameter :: NL=1.
        -:  272:      character*7 tname
        1:  273:      real, allocatable :: A(:,:),C(:,:)
        -:  274:      real iprod1,iprodt1 
        -:  275:      real NNl
        -:  276:      intrinsic INT           
        -:  277:!dvm$ distribute A(BLOCK,BLOCK)    
        -:  278:
        1:  279:      tname='RED2106'
       1*:  280:      allocate (A(N,M),C(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  281:      NNL=NL
        1:  282:      NN=N
        1:  283:      MM=M
        1:  284:      call serprodr2(C,NN,Mm,NNL,iprod1)
        1:  285:      iprodt1 = 1.
        -:  286:
        -:  287:!dvm$ actual(iprodt1)
        -:  288:!dvm$ region local(A)
        -:  289:!dvm$ parallel (i,j) on A(i,j)
        9:  290:      do i=1,N
call    0 returned 100%
branch  1 taken 89% (fallthrough)
branch  2 taken 11%
       57:  291:         do j=1,M
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
       56:  292:            if(i.eq.j) then
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        6:  293:               A(i,j) = I+NL
        -:  294:            else
       42:  295:               A(i,j) = 1.
        -:  296:            endif
        -:  297:         enddo
        -:  298:      enddo
        -:  299:  
        -:  300:!dvm$ parallel (i,j) on A(i,j), reduction( product( iprodt1 ) )
        9:  301:      do i=1,N
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       57:  302:         do j=1,M
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
       56:  303:           iprodt1 = iprodt1*A(i,j)
        -:  304:         enddo
        -:  305:      enddo
        -:  306:!dvm$ end region   
        -:  307:!dvm$ get_actual(iprodt1) 
        1:  308:       if(INT(iprod1) .eq. INT(iprodt1))  then
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  309:          call ansyes(tname)
call    0 returned 100%
        -:  310:      else
    #####:  311:          call ansno(tname)
call    0 never executed
        -:  312:      endif 
       1*:  313:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  314: 
        1:  315:      end
        -:  316:C -----------------------------------------------------RED2107
function red2107_ called 1 returned 100% blocks executed 89%
        1:  317:      subroutine RED2107
        -:  318:      integer, parameter :: N = 16,M=8
        -:  319:      character*7 tname
        1:  320:      logical, allocatable :: A(:,:),C(:,:)
        -:  321:      logical land1,landt1,leqv1,lneqv1,lor1
        -:  322:
        -:  323:!dvm$ distribute A(BLOCK,BLOCK)     
        -:  324:
        1:  325:      tname='RED2107'
       1*:  326:      allocate (A(N,M),C(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  327:      NN=N
        1:  328:      MM=M     
        1:  329:      call serlog2(C,NN,MM,land1,lor1,leqv1,lneqv1)
        -:  330:
        -:  331:!dvm$ parallel (i,j) on A(i,j)
       17:  332:      do i=1,N
call    0 returned 100%
branch  1 taken 6% (fallthrough)
branch  2 taken 94%
        1:  333:         do j=1,M,2
       64:  334:           A(i,J) = .true. 
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  335:         enddo        
        -:  336:      enddo
        -:  337:
        -:  338:!dvm$ parallel (i,j) on A(i,j)
       17:  339:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        1:  340:         do j=2,M,2
       64:  341:           A(i,j)=.false.
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  342:         enddo
        -:  343:      enddo
        -:  344:
        -:  345:!dvm$ remote_access (A(1,1))
        1:  346:      landt1 = A(1,1)
        -:  347:
        -:  348:!dvm$ actual(landt1)
        -:  349:!dvm$ region
        -:  350:!dvm$ parallel (i,j) on A(i,j), reduction( AND( landt1 ) )
       17:  351:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  352:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  353:          if ((i.eq.1).and.(j.eq.1))  then
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  354:          continue
        -:  355:!           landt1=A(i,j)
        -:  356:          else
      127:  357:           landt1 = landt1 .and. A(i,j)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  358:          endif
        -:  359:         enddo
        -:  360:      enddo
        -:  361:!dvm$ end region   
        -:  362:!dvm$ get_actual(landt1) 
        -:  363:
        1:  364:      if (land1 .eqv.landt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  365:          call ansyes(tname)
call    0 returned 100%
        -:  366:      else
    #####:  367:          call ansno(tname)
call    0 never executed
        -:  368:      endif 
       1*:  369:      deallocate (A,C) 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  370:
        1:  371:      end
        -:  372:C -----------------------------------------------------RED2108
function red2108_ called 1 returned 100% blocks executed 88%
        1:  373:      subroutine RED2108
        -:  374:      integer, parameter :: N = 16,M=8
        -:  375:      character*7 tname
        1:  376:      logical, allocatable :: A(:,:),C(:,:)
        -:  377:      logical land1,landt1,lor1,lort1,leqv1,lneqv1
        -:  378:
        -:  379:!dvm$ distribute A(BLOCK,BLOCK)   
        -:  380:
        1:  381:      tname='RED2108'
       1*:  382:      allocate (A(N,M),C(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  383:      NN=N
        1:  384:      MM=M
        1:  385:      call serlog2(C,NN,MM,land1,lor1,leqv1,lneqv1)                                    
        -:  386:               
        -:  387:!dvm$ parallel (i,j) on A(i,j)
       17:  388:      do i=1,N
call    0 returned 100%
branch  1 taken 6% (fallthrough)
branch  2 taken 94%
        1:  389:         do j=1,M,2
       64:  390:           A(i,J) = .true.
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  391:         enddo
        -:  392:      enddo
        -:  393:
        -:  394:!dvm$ parallel (i,j) on A(i,j)
       17:  395:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        1:  396:         do j=2,M,2
       64:  397:           A(i,j)=.false.
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  398:         enddo
        -:  399:      enddo
        -:  400:
        -:  401:!dvm$ remote_access (A(1,1))
        1:  402:      lort1 = A(1,1)
        -:  403:
        -:  404:!dvm$ actual(lort1)
        -:  405:!dvm$ region
        -:  406:!dvm$ parallel (i,j) on A(i,j), reduction( OR( lort1 ) )
        1:  407:      do i=1,N
        -:  408:         do j=1,M
        -:  409:          if ((i.eq.1).and.(j.eq.1))  then
        -:  410:          continue
        -:  411:!           lort1=A(i,j)
        -:  412:          else
        -:  413:           lort1 = lort1 .or. A(i,j)
        -:  414:          endif
        -:  415:         enddo
        -:  416:      enddo
        -:  417:!dvm$ end region   
        -:  418:!dvm$ get_actual(lort1) 
        -:  419:
        1:  420:      if (lort1 .eqv.lort1) then     
call    0 returned 100%
        -:  421:          call ansyes(tname)
        -:  422:      else
        -:  423:          call ansno(tname)
        -:  424:      endif 
       1*:  425:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  426:
        1:  427:      end
        -:  428:C -----------------------------------------------------RED2109
function red2109_ called 1 returned 100% blocks executed 89%
        1:  429:      subroutine RED2109
        -:  430:      integer, parameter :: N = 16,M=8
        -:  431:      character*7 tname
        1:  432:      logical, allocatable :: A(:,:),C(:,:)
        -:  433:      logical land1,landt1,lor1,leqv1,leqvt1,lneqv1
        -:  434:
        -:  435:!dvm$ distribute A(BLOCK,BLOCK)
        -:  436:
        1:  437:      tname='RED2109'
       1*:  438:      allocate (A(N,M),C(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  439:      NN=N
        1:  440:      MM=M
        1:  441:      call serlog2(C,NN,MM,land1,lor1,leqv1,lneqv1)
        -:  442:                                    
        -:  443:!dvm$ parallel (i,j) on A(i,j)
       17:  444:      do i=1,N
call    0 returned 100%
branch  1 taken 6% (fallthrough)
branch  2 taken 94%
        1:  445:         do j=1,M,2
       64:  446:           A(i,J) = .true.
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  447:         enddo         
        -:  448:      enddo
        -:  449:
        -:  450:!dvm$ parallel (i,j) on A(i,j)
       17:  451:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        1:  452:         do j=2,M,2
       64:  453:           A(i,j)=.false.
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  454:         enddo
        -:  455:      enddo
        -:  456:
        -:  457:!dvm$ remote_access (A(1,1))
        1:  458:      leqvt1 = A(1,1)
        -:  459:
        -:  460:!dvm$ actual(leqvt1)
        -:  461:!dvm$ region
        -:  462:!dvm$ parallel (i,j) on A(i,j), reduction( EQV( leqvt1 ) )
       17:  463:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  464:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  465:          if ((i.eq.1).and.(j.eq.1))  then
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  466:          continue
        -:  467:!           leqvt1=A(i,j)
        -:  468:          else
      127:  469:           leqvt1 = leqvt1 .eqv. A(i,j)
        -:  470:          endif
        -:  471:         enddo
        -:  472:      enddo
        -:  473:!dvm$ end region   
        -:  474:!dvm$ get_actual(leqvt1) 
        -:  475:      
        1:  476:      if (leqv1 .eqv.leqvt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  477:          call ansyes(tname)
call    0 returned 100%
        -:  478:      else
    #####:  479:          call ansno(tname)
call    0 never executed
        -:  480:      endif 
       1*:  481:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  482: 
        1:  483:      end
        -:  484:C -----------------------------------------------------RED2110
function red2110_ called 1 returned 100% blocks executed 89%
        1:  485:      subroutine RED2110
        -:  486:      integer, parameter :: N = 16,M=8
        -:  487:      character*7 tname
        1:  488:      logical, allocatable :: A(:,:),C(:,:)
        -:  489:      logical land1,landt1,lor1,leqv1,lneqv1,lneqvt1
        -:  490:
        -:  491:!dvm$ distribute A(BLOCK,BLOCK)
        -:  492:
        1:  493:      tname='RED2110'
       1*:  494:      allocate (A(N,M),C(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  495:
        1:  496:      NN=N
        1:  497:      MM=M
        1:  498:      call serlog2(C,NN,MM,land1,lor1,leqv1,lneqv1)
        -:  499:               
        -:  500:!dvm$ parallel (i,j) on A(i,j)
       17:  501:      do i=1,N
call    0 returned 100%
branch  1 taken 6% (fallthrough)
branch  2 taken 94%
        1:  502:         do j=1,M,2
       64:  503:           A(i,J) = .true.
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  504:         enddo         
        -:  505:      enddo
        -:  506:
        -:  507:!dvm$ parallel (i,j) on A(i,j)
       17:  508:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        1:  509:         do j=2,M,2
       64:  510:           A(i,j)=.false.
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  511:         enddo
        -:  512:      enddo
        -:  513:
        -:  514:!dvm$ remote_access (A(1,1))
        1:  515:      lneqvt1 = A(1,1)
        -:  516:
        -:  517:!dvm$ actual(lneqvt1)
        -:  518:!dvm$ region
        -:  519:!dvm$ parallel (i,j) on A(i,j), reduction( NEQV( lneqvt1 ) )
       17:  520:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  521:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  522:          if ((i.eq.1).and.(j.eq.1))  then
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  523:           continue
        -:  524:!           lneqvt1=A(i,j)
        -:  525:          else
      127:  526:           lneqvt1 = lneqvt1 .neqv. A(i,j)
        -:  527:          endif
        -:  528:         enddo
        -:  529:      enddo
        -:  530:!dvm$ end region   
        -:  531:!dvm$ get_actual(lneqvt1) 
        -:  532:      
        1:  533:      if (lneqv1 .eqv.lneqvt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  534:          call ansyes(tname)
call    0 returned 100%
        -:  535:      else
    #####:  536:          call ansno(tname)
call    0 never executed
        -:  537:      endif 
       1*:  538:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  539: 
        1:  540:      end
        -:  541:C ----------------------------------------------------RED2111
function red2111_ called 1 returned 100% blocks executed 87%
        1:  542:      subroutine RED2111
        -:  543:      integer, parameter :: N = 16,M=8,NL=1000
        -:  544:      character*7 tname
        1:  545:      integer, allocatable :: A(:,:),C(:,:)
        -:  546:      integer imax1,imaxt1 ,ni,imin,nj
        -:  547:      integer it1,jt1,it2,jt2
        -:  548:      integer coor(2),lcoor           
        -:  549:!dvm$ distribute A(BLOCK,BLOCK)
        -:  550:
        1:  551:      tname='RED2111'
       1*:  552:      allocate (A(N,M),C(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  553:     
        -:  554:!dvm$ parallel (i,j) on A(i,j)
       17:  555:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  556:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  557:           A(i,j) = i * NL + j
        -:  558:         enddo
        -:  559:      enddo
        1:  560:      ni=N/2
        1:  561:      nj=M/2
        1:  562:      A(ni,nj)=N+M+1+NL * NL
        1:  563:      imax1=N+M+1+NL * NL
        -:  564:
        -:  565:!dvm$ remote_access (A(1,1))
        1:  566:      imaxt1=A(1,1)  
        -:  567:
        1:  568:      lcoor=2
        1:  569:      coor(1)=0
        1:  570:      coor(2)=0
        -:  571:
        -:  572:!dvm$ actual(imaxt1,coor,lcoor)
        -:  573:!dvm$ region
        -:  574:!dvm$ parallel (i,j) on A(i,j), reduction( maxloc( imaxt1,coor,2))
       16:  575:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      136:  576:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      135:  577:          if (A(i,j).GT.imaxt1)then
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
       52:  578:           imaxt1=A(i,j)
       52:  579:           coor(1)=i
       52:  580:           coor(2)=j         
        -:  581:          endif
        -:  582:         enddo
        -:  583:      enddo
        -:  584:!dvm$ end region   
        -:  585:!dvm$ get_actual(imaxt1,coor)
        -:  586:
        -:  587:      if ((imax1 .eq.imaxt1) .and.(coor(1).eq.ni)
        1:  588:     *.and.(coor(2).eq.nj)) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        1:  589:          call ansyes(tname)
call    0 returned 100%
        -:  590:      else
    #####:  591:          call ansno(tname)
call    0 never executed
        -:  592:      endif 
       1*:  593:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  594:      
        1:  595:      end
        -:  596:C ----------------------------------------------------RED2112
function red2112_ called 1 returned 100% blocks executed 87%
        1:  597:      subroutine RED2112
        -:  598:      integer, parameter :: N = 16,M=8,NL=1000
        -:  599:      character*7 tname
        1:  600:      integer, allocatable :: A(:,:),C(:,:)
        -:  601:      integer imin1,imint1 ,ni
        -:  602:c      integer it1,jt1,it2,jt2 
        -:  603:      integer coor(2),lcoor
        -:  604:                
        -:  605:!dvm$ distribute A(BLOCK,BLOCK)
        -:  606:
        1:  607:      tname='RED2112'
       1*:  608:      allocate (A(N,M),C(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  609:     
        -:  610:!dvm$ parallel (i,j) on A(i,j)
       17:  611:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  612:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  613:           A(i,j) = i * NL + j
        -:  614:         enddo
        -:  615:      enddo
        1:  616:      ni=N/2
        1:  617:      nj=M/2 
        1:  618:      A(ni,nj)=-(N+M+1+NL * NL)
        1:  619:      imin1=-(N+M+1+NL * NL)
        -:  620:
        -:  621:!dvm$ remote_access (A(1,1))
        1:  622:      imint1=A(1,1)  
        -:  623:
        1:  624:      lcoor=2
        1:  625:      coor(1)=0
        1:  626:      coor(2)=0
        -:  627:
        -:  628:!dvm$ actual(imint1,coor,lcoor)
        -:  629:!dvm$ region
        -:  630:!dvm$ parallel (i,j) on A(i,j), reduction( minloc( imint1,coor,2))
       16:  631:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      136:  632:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      135:  633:          if (A(i,j).LT.imint1)then
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        1:  634:           imint1=A(i,j)
        1:  635:           coor(1)=i
        1:  636:           coor(2)=j
        -:  637:          endif
        -:  638:         enddo
        -:  639:      enddo
        -:  640:!dvm$ end region   
        -:  641:!dvm$ get_actual(imint1,coor) 
        -:  642:
        -:  643:c      print *,imin1, imint1
        -:  644:c      print *,coor(1),ni
        -:  645:c      print *,coor(2),nj
        -:  646:      if ((imin1 .eq.imint1) .and.(coor(1).eq.ni)
        1:  647:     *.and.(coor(2).eq.nj)) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        1:  648:          call ansyes(tname)
call    0 returned 100%
        -:  649:      else
    #####:  650:          call ansno(tname)
call    0 never executed
        -:  651:      endif 
       1*:  652:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  653:      
        1:  654:      end
        -:  655:C ----------------------------------------------------RED2113
function red2113_ called 1 returned 100% blocks executed 85%
        1:  656:      subroutine RED2113
        -:  657:      integer, parameter :: N = 16,M=8,NL=1000
        -:  658:      character*7 tname
        1:  659:      integer, allocatable :: A(:,:),C(:,:)
        -:  660:      integer imin1,imint1 ,ni
        -:  661:      integer isum1,isumt1 
        -:  662:      integer imax1,imaxt1
        -:  663:                      
        -:  664:!dvm$ distribute A(BLOCK,BLOCK)
        -:  665:
        1:  666:      tname='RED2113'
       1*:  667:      allocate (A(N,M),C(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  668:      NNL=NL 
        1:  669:      NN=N
        1:  670:      MM=M
        1:  671:      call sersum2m(C,NN,MM,NNL,isum1)
        -:  672:
        -:  673:!dvm$ parallel (i,j) on A(i,j)
       17:  674:      do i=1,N
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
      145:  675:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  676:           A(i,j) = i+j+NL
        -:  677:         enddo
        -:  678:      enddo
        1:  679:      ni=N/2-1
        1:  680:      nj=M/2-1
        1:  681:      A(ni,nj)=N+M+1+NL
        1:  682:      imax1=N+M+1+NL
        -:  683:
        -:  684:!dvm$ remote_access (A(1,1))
        1:  685:      imaxt1=A(1,1)  
        -:  686:
        1:  687:      ni1=N/2
        1:  688:      nj1=M/2
        1:  689:      A(ni1,nj1)=-(N+M+1+NL)
        1:  690:      imin1=-(N+M+1+NL)
        -:  691:
        -:  692:!dvm$ remote_access (A(1,1))
        1:  693:      imint1=A(1,1)
        -:  694:
        1:  695:      isumt1 = 0
        -:  696:!dvm$ actual(isumt1,imaxt1,imint1)
        -:  697:!dvm$ region
        -:  698:!dvm$ parallel (i,j) on A(i,j), reduction( sum( isumt1 ),
        -:  699:!dvm$*max( imaxt1 ),min( imint1 ) )
       17:  700:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  701:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      128:  702:           isumt1 = isumt1+A(i,j)
      128:  703:           if (A(i,j).GT.imaxt1) imaxt1=A(i,j)
      144:  704:           if (A(i,j).LT.imint1) imint1=A(i,j)
        -:  705:         enddo
        -:  706:      enddo
        -:  707:!dvm$ end region   
        -:  708:!dvm$ get_actual(isumt1,imaxt1,imint1) 
        -:  709:
        -:  710:c      print *,isumt1,isum1
        -:  711:c      print *,imaxt1,imax1
        -:  712:c      print *,imint1,imin1
        -:  713:      if ((isum1 .eq.isumt1) .and.(imax1 .eq.imaxt1)
        1:  714:     *   .and.(imin1 .eq.imint1))   then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  715:          call ansyes(tname)
call    0 returned 100%
        -:  716:      else
    #####:  717:          call ansno(tname)
call    0 never executed
        -:  718:      endif 
       1*:  719:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  720:
        1:  721:      end
        -:  722:C ----------------------------------------------------RED2114
function red2114_ called 1 returned 100% blocks executed 86%
        1:  723:      subroutine RED2114
        -:  724:      integer, parameter :: N = 16,M=8,NL=1
        -:  725:      character*7 tname
        1:  726:      integer, allocatable :: A(:,:),C(:,:)
        -:  727:      integer iprod1,iprodt1 
        1:  728:      logical, allocatable :: B(:,:),CL(:,:)
        -:  729:      logical land1,landt1,lor1,leqv1,lneqv1
        -:  730:                 
        -:  731:!dvm$ distribute A(BLOCK,BLOCK)    
        -:  732:!dvm$ align B(I,J) with A(I,J)      
        -:  733:
        1:  734:      tname='RED2114'
       1*:  735:      allocate (A(N,M),C(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
       1*:  736:      allocate (B(N,M),CL(N,M))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  737:      NNL=NL
        1:  738:      NN=N
        1:  739:      MM=M
        1:  740:      call serprod2(C,NN,MM,NNL,iprod1)
call    0 returned 100%
        1:  741:      call serlog2(CL,NN,MM,land1,lor1,leqv1,lneqv1)
        -:  742:
        -:  743:!dvm$ parallel (i,j) on B(i,j)
       17:  744:      do i=1,N
call    0 returned 100%
branch  1 taken 6% (fallthrough)
branch  2 taken 94%
        1:  745:         do j=1,M,2
       64:  746:           B(i,J) = .true.
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  747:         enddo         
        -:  748:      enddo
        -:  749:
        -:  750:!dvm$ parallel (i,j) on B(i,j)
       17:  751:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        1:  752:         do j=2,M,2
       64:  753:           B(i,j)=.false.
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  754:         enddo
        -:  755:      enddo
        -:  756:          
        -:  757:!dvm$ remote_access (B(1,1))
        1:  758:      landt1 = B(1,1)    
        -:  759:               
        -:  760:!dvm$ parallel (i,j) on A(i,j)
       17:  761:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  762:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  763:           A(i,j) = i+j+NL
        -:  764:         enddo
        -:  765:      enddo
        -:  766:  
        -:  767:C      print *,A
        -:  768:      iprodt1 = 1
        -:  769:
        -:  770:!dvm$ actual(iprodt1,landt1)
        -:  771:!dvm$ region
        -:  772:!dvm$ parallel (i,j) on A(i,j), reduction( product( iprodt1 ),
        -:  773:!dvm$* and(landt1))
       17:  774:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  775:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      128:  776:          iprodt1 = iprodt1*A(i,j)
        -:  777:c         print *,i, j,iprodt1
      144:  778:          if ((i.eq.1).and.(j.eq.1))  then
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  779:          continue
        -:  780:!           landt1=B(i,j)
        -:  781:          else
      127:  782:           landt1 = landt1 .and. B(i,j)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  783:          endif
        -:  784:         enddo
        -:  785:      enddo
        -:  786:!dvm$ end region   
        -:  787:!dvm$ get_actual(iprodt1,landt1) 
        -:  788:
        -:  789:c      print *,iprod1,iprodt1,land1,landt1
        -:  790:      if ((iprod1 .eq.iprodt1)
        1:  791:     *.and. (land1 .eqv.landt1)) then       
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  792:          call ansyes(tname)
call    0 returned 100%
        -:  793:      else
    #####:  794:          call ansno(tname)
call    0 never executed
        -:  795:      endif 
       1*:  796:      deallocate (B,CL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       1*:  797:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  798: 
        1:  799:      end   
        -:  800:C -----------------------------------------------------
        -:  801:
function sersum2_ called 1 returned 100% blocks executed 100%
        1:  802:      subroutine sersum2(AR,N,M,NL,S)
        -:  803:      integer AR(N,M)
        -:  804:      integer S,NL
       17:  805:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  806:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  807:         AR(i,j) = i+j+NL
        -:  808:         enddo          
        -:  809:      enddo
        1:  810:      S=0
       17:  811:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  812:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  813:         s = s+ AR(i,j)
        -:  814:         enddo
        -:  815:      enddo
        1:  816:      end   
        -:  817:   
function sersum2m_ called 1 returned 100% blocks executed 100%
        1:  818:      subroutine sersum2m(AR,N,M,NL,S)
        -:  819:      integer AR(N,M)
        -:  820:      integer S,NL
       17:  821:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  822:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  823:          AR(i,j) = i+j+NL
        -:  824:         enddo          
        -:  825:      enddo
        1:  826:      ni=N/2-1
        1:  827:      nj=M/2-1
        1:  828:      AR(ni,nj)=N+M+1+NL
        1:  829:      ni=N/2 
        1:  830:      nj=M/2
        1:  831:      AR(ni,nj)=-(N+M+1+NL)
        1:  832:      S=0
       17:  833:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      145:  834:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      144:  835:          s = s+ AR(i,j)
        -:  836:         enddo
        -:  837:      enddo
        -:  838:    
        1:  839:      end   
        -:  840:
function sersum2mr_ called 0 returned 0% blocks executed 0%
    #####:  841:      subroutine sersum2mr(AR,N,M,NL,S)
        -:  842:      real AR(N,M)
        -:  843:      real S,NL
    #####:  844:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  845:         do j=1,M
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  846:          AR(i,j) = i+j+NL
        -:  847:         enddo 
        -:  848:         enddo 
    #####:  849:      ni=N/2-1
    #####:  850:      nj=M/2-1
    #####:  851:      AR(ni,nj)=N+M+1.+NL
    #####:  852:      ni=N/2
    #####:  853:      nj=M/2
    #####:  854:      AR(ni,ni)=-(N+M+1.+NL)
    #####:  855:      S=0.
    #####:  856:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  857:         do j=1,M
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  858:          s = s+ AR(i,j)
        -:  859:         enddo
        -:  860:      enddo
    #####:  861:      end  
        -:  862:  
function serprod2_ called 2 returned 100% blocks executed 100%
        2:  863:      subroutine serprod2(AR,N,M,NL,P)
        -:  864:      integer AR(N,M)
        -:  865:      integer P,NL
       34:  866:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      290:  867:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      288:  868:          AR(i,j) = i+j+NL
        -:  869:         enddo
        -:  870:      enddo   
        2:  871:      P=1
       34:  872:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      290:  873:         do j=1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      288:  874:          P = P* AR(i,j)
        -:  875:         enddo
        -:  876:      enddo
        2:  877:      end   
        -:  878: 
function serprodr2_ called 1 returned 100% blocks executed 100%
        1:  879:      subroutine serprodr2(AR,N,M,NL,P)
        -:  880:      real AR(N,M)
        -:  881:      real P,NL
        9:  882:      do i=1,N
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       57:  883:         do j=1,M
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
       56:  884:            if(i.eq.j)then
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        6:  885:               AR(i,j) = I+NL
        -:  886:            else
       42:  887:               AR(i,j) = 1.  
        -:  888:            endif  
        -:  889:         enddo
        -:  890:      enddo 
        1:  891:      P=1.
        9:  892:      do i=1,N
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
       57:  893:         do j=1,M
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
       56:  894:          P = P* AR(i,j)
        -:  895:         enddo
        -:  896:      enddo
        1:  897:      end
        -:  898:     
function serlog2_ called 5 returned 100% blocks executed 92%
        5:  899:      subroutine serlog2(AR,N,M,LAND,LOR,LEQV,LNEQV)
        -:  900:      logical AR(N,M)
        -:  901:      logical LAND,LOR,LEQV,LNEQV
       85:  902:      do  i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       85:  903:         do j=1,M,2
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     320*:  904:          AR(i,J) = .true.
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  905:          enddo         
        -:  906:      enddo
       85:  907:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       85:  908:         do j=2,M,2
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     320*:  909:          AR(i,j)=.false.
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  910:         enddo
        -:  911:      enddo 
       85:  912:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      725:  913:       do j= 1,M
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
      720:  914:        if ((i.eq.1).and.(j.eq.1))  then
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        5:  915:         LAND=AR(1,1)
        5:  916:         LOR=AR(1,1)
        -:  917:C         LEQV=.true.
        -:  918:C         LNEQV=.false.
        5:  919:          LNEQV=AR(1,1)
        5:  920:          LEQV=AR(1,1)
        -:  921:        else
      635:  922:         LAND = LAND .and. AR(i,j)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     635*:  923:         LOR = LOR .or.AR(i,j)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed (fallthrough)
branch  3 never executed
      635:  924:         LEQV = LEQV .eqv. AR(i,j)
      635:  925:         LNEQV = LNEQV .neqv. AR(i,j)
        -:  926:        endif
        -:  927:       enddo
        -:  928:      enddo
        5:  929:      end   
        -:  930:
function ansyes_ called 14 returned 100% blocks executed 100%
       14:  931:      subroutine ansyes(name)
        -:  932:      character*7 name
       14:  933:      print *,name,'  -  complete'
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       14:  934:      end
function ansno_ called 0 returned 0% blocks executed 0%
    #####:  935:      subroutine ansno(name)
        -:  936:      character*7 name
    #####:  937:      print *,name,'  -  ***error'
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  938:      end
