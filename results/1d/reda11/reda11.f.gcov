        -:    0:Source:results/1d/reda11/reda11.f
        -:    0:Graph:./results\1d\reda11\reda11.gcno
        -:    0:Data:./results\1d\reda11\reda11.gcda
        -:    0:Runs:1
function MAIN__ called 1 returned 100% blocks executed 100%
        1:    1:      program REDA11
        -:    2:
        -:    3:c    TESTING OF THE REDUCTION_GROUP DIRECTIVE,REDUCTION_START
        -:    4:c    DIRECTIVE,REDUCTION_WAIT DIRECTIVE.
        -:    5:c    REDUCTION GROUP IS EXECUTED FOR DISTRIBUTED ARRAY A(N).  
        -:    6:c
        -:    7:
        1:    8:      print *,'===START OF REDA11========================'
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:    9:C --------------------------------------------------
        1:   10:      call reda1101
call    0 returned 100%
        -:   11:C --------------------------------------------------
        1:   12:      call reda1102
call    0 returned 100%
        -:   13:C --------------------------------------------------
        1:   14:      call reda1103
call    0 returned 100%
        -:   15:C --------------------------------------------------
        1:   16:      call reda1104
call    0 returned 100%
        -:   17:C --------------------------------------------------
        -:   18:C
        1:   19:      print *,'=== END OF REDA11 ========================= '    
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   20:
function main called 1 returned 100% blocks executed 100%
        1:   21:      end
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   22:
        -:   23:C ----------------------------------------------------REDA1101
function reda1101_ called 1 returned 100% blocks executed 79%
        1:   24:      subroutine REDA1101
        -:   25:      integer, parameter :: N = 16,NL=1000
        1:   26:      integer, allocatable :: A(:),C(:)
        -:   27:      integer isum1,isumt1 
        -:   28:      integer imax1,imaxt1 ,ni,imin1,imint1
        -:   29:      character(8) :: tname='REDA1101'
        -:   30:
        -:   31:!dvm$ distribute A(BLOCK)     
        -:   32:!dvm$ reduction_group smaxmin
       1*:   33:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:   34:      NNL=NL 
        1:   35:      NN=N
        1:   36:      call sersum1m(C,NN,NNL,isum1)
        -:   37:
        -:   38:!dvm$ parallel (i) on A(i)
       17:   39:      do i=1,N
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
       17:   40:         A(i) = i+NL
        -:   41:      enddo
        -:   42:
        -:   43:
        1:   44:      ni=N/2-1
        1:   45:      A(ni)=N+1+NL
        1:   46:      imax1=N+1+NL
        -:   47:
        -:   48:!dvm$ remote_access (A(1))
        1:   49:      imaxt1=A(1)  
        -:   50:
        1:   51:      ni=N/2
        1:   52:      A(ni)=-(N+1+NL)
        1:   53:      imin1=-(N+1+NL)
        -:   54:
        -:   55:!dvm$ remote_access (A(1))      
        1:   56:      imint1=A(1)
        -:   57:  
        1:   58:      isumt1 = 0
        -:   59:
        -:   60:!dvm$ parallel (i) on A(i),
        -:   61:!dvm$*reduction(smaxmin:sum(isumt1),max(imaxt1),min(imint1))
       17:   62:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:   63:         isumt1 = isumt1+A(i)
       16:   64:         if (A(i).GT.imaxt1) imaxt1=A(i)
       17:   65:         if (A(i).LT.imint1) imint1=A(i)
        -:   66:      enddo
        -:   67:
        -:   68:!dvm$ reduction_start smaxmin
        -:   69:!dvm$ reduction_wait smaxmin
        -:   70:
        -:   71:      if ((isum1 .eq.isumt1) .and.(imax1 .eq.imaxt1)
        1:   72:     *   .and.(imin1 .eq.imint1))   then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:   73:          call ansyes(tname)
call    0 returned 100%
        -:   74:      else
    #####:   75:          call ansno(tname)
call    0 never executed
        -:   76:      endif 
        -:   77: 
       1*:   78:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   79:
        1:   80:      end
        -:   81:
        -:   82:C -----------------------------------------------------REDA1102
function reda1102_ called 1 returned 100% blocks executed 84%
        1:   83:      subroutine REDA1102
        -:   84:      integer, parameter :: N = 16, NL=1000
        1:   85:      integer, allocatable :: A(:),C(:)
        -:   86:      integer iprod1,iprodt1 
        1:   87:      logical, allocatable :: B(:),CL(:)
        -:   88:      logical land1,landt1,lor1,leqv1,lneqv1
        -:   89:      character(8) :: tname='REDA1102'
        -:   90:                 
        -:   91:!dvm$ distribute A(BLOCK)     
        -:   92:!dvm$ align B(I) with A(I)
        -:   93:!dvm$ reduction_group prodand      
       1*:   94:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
       1*:   95:      allocate (B(N),CL(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:   96:      NNL=NL
        1:   97:      NN=N
        2:   98:      call serprod1(C,NN,NNL,iprod1)
        1:   99:      call serlog1(CL,NN,land1,lor1,leqv1,lneqv1)  
        -:  100:               
        -:  101:!dvm$ parallel (i) on B(i)
        1:  102:      do i=1,N,2
call    0 returned 100%
        8:  103:         B(i) = .true.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  104:      enddo
        -:  105:!dvm$ parallel (i) on B(i+1)
        8:  106:      do i=1,N-1,2
        8:  107:         B(i+1)=.false.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  108:      enddo
        -:  109:
        -:  110:!dvm$ remote_access (B(1))
        1:  111:      landt1 = B(1)
        -:  112:
        -:  113:!dvm$ parallel (i) on A(i)
       17:  114:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       17:  115:         A(i) = i+NL
        -:  116:      enddo
        -:  117:  
        -:  118:      iprodt1 = 1
        -:  119:
        -:  120:!dvm$ parallel (i) on B(i),
        -:  121:!dvm$*reduction(prodand:product( iprodt1 ),and(landt1))
       17:  122:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       16:  123:         iprodt1 = iprodt1*A(i)
       32:  124:         landt1 = landt1 .and.B(i)
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        -:  125:      enddo
        -:  126:
        -:  127:!dvm$ reduction_start prodand
        -:  128:
        -:  129:!dvm$ parallel (i) on A(i)
       17:  130:      do  i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  131:         A(i) = i+NL
        -:  132:      enddo
        -:  133:
        -:  134:!dvm$ reduction_wait prodand
        -:  135:
        -:  136:      if ((iprod1 .eq.iprodt1)
        1:  137:     *.and. (land1 .eqv.landt1)) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  138:          call ansyes(tname)
call    0 returned 100%
        -:  139:       else
    #####:  140:          call ansno(tname)
call    0 never executed
        -:  141:      endif 
        -:  142: 
       1*:  143:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
       1*:  144:      deallocate (B,CL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  145: 
        1:  146:      end
        -:  147:
        -:  148:C ----------------------------------------------------REDA1103
function reda1103_ called 1 returned 100% blocks executed 83%
        1:  149:      subroutine REDA1103
        -:  150:      integer, parameter :: N = 8,NL=1000
        1:  151:      integer, allocatable :: A(:),C(:)
        -:  152:      integer imax1,imaxt1 ,ni,imin1,imint1,it1,it2,lit
        -:  153:      integer imaxloct1,iminloct1
        -:  154:      character(8) :: tname='REDA1103'
        -:  155:
        -:  156:!dvm$ distribute A(BLOCK)    
        -:  157:!dvm$ reduction_group locmaxmin
        -:  158:c dvm$ reduction_group maxminloc
        -:  159:
       1*:  160:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  161:      
        -:  162:!dvm$ parallel (i) on A(i)
        9:  163:      do i=1,N
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
        9:  164:         A(i) = i+NL
        -:  165:      enddo
        -:  166:
        1:  167:      ni=N/2+2
        1:  168:      A(ni)=N+1+NL
        1:  169:      imax1=N+1+NL
        -:  170:
        -:  171:!dvm$ remote_access (A(1))
        1:  172:      imaxt1=A(1)  
        -:  173:
        1:  174:      imaxloct1=imaxt1
        1:  175:      ni1=N/2+1
        1:  176:      A(ni1)=-(N+1+NL)
        1:  177:      imin1=-(N+1+NL)
        -:  178:
        -:  179:!dvm$ remote_access (A(1))      
        1:  180:      imint1=A(1)
        -:  181:
        1:  182:      iminloct1=imint1
        1:  183:      lit=1
        1:  184:      it1=0
        1:  185:      it2=0
        -:  186:
        -:  187:!dvm$ parallel (i) on A(i),
        -:  188:!dvm$*reduction(locmaxmin:max( imaxt1 ),
        -:  189:!dvm$*maxloc( imaxloct1,it1,lit),
        -:  190:!dvm$*minloc( iminloct1,it2,lit))
        -:  191:
        9:  192:      do i=1,N
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
        8:  193:         if (A(i).GT.imaxt1) imaxt1 =A(i)
        8:  194:         if (A(i).GT.imaxloct1) then
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        4:  195:	   imaxloct1=A(i)
        4:  196:           it1=i 
        -:  197:         endif
        9:  198:         if (A(i).LT.iminloct1) then
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        1:  199:           iminloct1=A(i)
        1:  200:           it2=i
        -:  201:         endif
        -:  202:      enddo
        -:  203:
        -:  204:!dvm$ reduction_start locmaxmin
        -:  205:!dvm$ reduction_wait locmaxmin
        -:  206:
        -:  207:      if ((imaxloct1.eq.imax1).and.(iminloct1.eq.imin1)
        -:  208:     *.and.(imaxt1.eq.imaxloct1).and.(it1.eq.ni)
        1:  209:     *.and.(it2.eq.ni1) )   then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        1:  210:          call ansyes(tname)
call    0 returned 100%
        -:  211:      else
    #####:  212:          call ansno(tname)
call    0 never executed
        -:  213:      endif 
        -:  214: 
       1*:  215:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  216:
        1:  217:      end
        -:  218:
        -:  219:
        -:  220:C ----------------------------------------------------REDA1104
function reda1104_ called 1 returned 100% blocks executed 83%
        1:  221:      subroutine REDA1104
        -:  222:      integer, parameter :: N = 16
        -:  223:      real, parameter :: NL=1000.
        1:  224:      real, allocatable :: A(:),C(:)
        -:  225:      real isum1,isumt1
        -:  226:      real imax1,imaxt1 ,imin1,imint1
        -:  227:      real imaxloct1,iminloct1,NNL
        -:  228:      integer it1,it2,ni,ni1,lit          
        -:  229:      character(8) :: tname='REDA1104'
        -:  230:
        -:  231:!dvm$ distribute A(BLOCK)     
        -:  232:!dvm$ reduction_group locsumloc
        -:  233:
       1*:  234:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  235:      NNL=NL 
        1:  236:      NN=N
        1:  237:      call sersum1mr(C,NN,NNL,isum1)
        -:  238:
        -:  239:!dvm$ parallel (i) on A(i)
       17:  240:      do i=1,N
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
       17:  241:         A(i) = i+NL
        -:  242:      enddo
        -:  243:
        1:  244:      ni=N/2+1
        1:  245:      A(ni)=N+1.+NL
        1:  246:      imax1=N+1.+NL
        -:  247:
        -:  248:!dvm$ remote_access (A(1))
        1:  249:      imaxt1=A(1)  
        -:  250:
        1:  251:      imaxloct1=imaxt1
        1:  252:      ni1=N/2+2
        1:  253:      A(ni1)=-(N+1.+NL)
        1:  254:      imin1=-(N+1.+NL)
        -:  255:
        -:  256:!dvm$ remote_access (A(1))      
        1:  257:      imint1=A(1)
        -:  258:
        1:  259:      iminloct1=imint1
        1:  260:      isumt1 = 0.
        1:  261:      lit=1
        1:  262:      it1=0
        1:  263:      it2=0
        -:  264:
        -:  265:!dvm$ parallel (i) on A(i),
        -:  266:!dvm$*reduction(locsumloc:sum( isumt1 ),
        -:  267:!dvm$*maxloc( imaxloct1,it1,lit),minloc( iminloct1,it2,lit ))
       17:  268:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  269:         isumt1 = isumt1+A(i)
       16:  270:         if (A(i).GT.imaxloct1) then
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        8:  271:           imaxloct1=A(i)
        8:  272:           it1=i
        -:  273:         endif         
       17:  274:         if (A(i).LT.iminloct1) then
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        1:  275:           iminloct1=A(i)
        1:  276:           it2=i
        -:  277:         endif
        -:  278:      enddo
        -:  279:
        -:  280:!dvm$ reduction_start locsumloc
        -:  281:!dvm$ reduction_wait locsumloc
        -:  282:
        -:  283:      if ((imaxloct1.eq.imax1).and.(iminloct1.eq.imin1)
        -:  284:     *.and.(isumt1.eq.isum1).and.(it1.eq.ni)
        1:  285:     *.and.(it2.eq.ni1) )   then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        1:  286:          call ansyes(tname)
call    0 returned 100%
        -:  287:      else
    #####:  288:          call ansno(tname)
call    0 never executed
        -:  289:      endif 
        -:  290: 
       1*:  291:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  292:
        1:  293:      end
        -:  294:
        -:  295:C -----------------------------------------------------
        -:  296:
function sersum1_ called 0 returned 0% blocks executed 0%
    #####:  297:      subroutine sersum1(AR,N,NL,S)
        -:  298:      integer AR(N)
        -:  299:      integer S,NL
    #####:  300:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  301:         AR(i) = i+NL
        -:  302:      enddo
    #####:  303:      S=0
    #####:  304:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  305:         s = s+ AR(i)
        -:  306:      enddo
    #####:  307:      end   
        -:  308:   
        -:  309:C ------
function sersum1m_ called 1 returned 100% blocks executed 100%
        1:  310:      subroutine sersum1m(AR,N,NL,S)
        -:  311:      integer AR(N)
        -:  312:      integer S,NL
       17:  313:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  314:         AR(i) = i+NL
        -:  315:      enddo
        1:  316:      ni=N/2-1
        1:  317:      AR(ni)=N+1+NL
        1:  318:      ni=N/2
        1:  319:      AR(ni)=-(N+1+NL)
        1:  320:      S=0
       17:  321:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  322:         s = s+ AR(i)
        -:  323:      enddo
        1:  324:      end 
        -:  325:  
        -:  326:C ------
function sersum1mr_ called 1 returned 100% blocks executed 100%
        1:  327:      subroutine sersum1mr(AR,N,NL,S)
        -:  328:      real AR(N)
        -:  329:      real S,NL
       17:  330:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  331:         AR(i) = i+NL
        -:  332:      enddo
        1:  333:      ni=N/2+1
        1:  334:      AR(ni)=N+1.+NL
        1:  335:      ni=N/2+2
        1:  336:      AR(ni)=-(N+1.+NL)
        1:  337:      S=0.
       17:  338:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  339:         S = S+ AR(i)
        -:  340:      enddo
        1:  341:      end  
        -:  342:  
        -:  343:C ------
function serprod1_ called 0 returned 0% blocks executed 0%
       1*:  344:      subroutine serprod1(AR,N,NL,P)
        -:  345:      integer AR(N)
        -:  346:      integer P,NL
      17*:  347:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
      17*:  348:         AR(i) = i+NL
        -:  349:      enddo
    #####:  350:      P=1
      17*:  351:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 taken 94% (fallthrough)
branch  3 taken 6%
      17*:  352:         P = P* AR(i)
        -:  353:      enddo
    #####:  354:      end   
        -:  355: 
function serprodr1_ called 0 returned 0% blocks executed 0%
    #####:  356:      subroutine serprodr1(AR,N,NL,P)
        -:  357:      real AR(N)
        -:  358:      real P,NL
    #####:  359:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  360:         AR(i) = i+NL
        -:  361:      enddo
    #####:  362:      P=1.
    #####:  363:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  364:         P = P* AR(i)
        -:  365:      enddo
    #####:  366:      end
        -:  367:     
        -:  368:C ------
function serlog1_ called 1 returned 100% blocks executed 89%
        1:  369:      subroutine serlog1(AR,N,LAND,LOR,LEQV,LNEQV)
        -:  370:      logical AR(N)
        -:  371:      logical LAND,LOR,LEQV,LNEQV
        1:  372:      do i=1,N,2
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:  373:         AR(i) = .true.
       8*:  374:         AR(i+1)=.false.          
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -:  375:      enddo
        1:  376:      LAND=AR(1)
        1:  377:      LOR=AR(1)
        1:  378:      LEQV=AR(1)
        1:  379:      LNEQV=AR(1)
       16:  380:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       15:  381:         LAND = LAND .and. AR(i)
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      31*:  382:         LOR = LOR .or.AR(i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  383:      enddo
        1:  384:      do i=1,N,2
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       8*:  385:         LEQV = LEQV .eqv. AR(i)
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -:  386:      enddo
       17:  387:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  388:         LNEQV = LNEQV .neqv. AR(i)
        -:  389:      enddo
        1:  390:      end   
        -:  391:
        -:  392:C -----------------------------------------------------
function ansyes_ called 4 returned 100% blocks executed 100%
        4:  393:      subroutine ansyes(name)
        -:  394:      character*8 name
        4:  395:      print *,name,'  -  complete'
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        4:  396:      end
function ansno_ called 0 returned 0% blocks executed 0%
    #####:  397:      subroutine ansno(name)
        -:  398:      character*8 name
    #####:  399:      print *,name,'  -  ***error'
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  400:      end
