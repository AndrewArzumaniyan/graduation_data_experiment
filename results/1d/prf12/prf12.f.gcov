        -:    0:Source:results/1d/prf12/prf12.f
        -:    0:Graph:./results\1d\prf12\prf12.gcno
        -:    0:Data:./results\1d\prf12\prf12.gcda
        -:    0:Runs:1
function MAIN__ called 1 returned 100% blocks executed 100%
        1:    1:      program PRF12
        -:    2:     
        -:    3:c    TESTING OF THE PREFETCH DIRECTIVE . 
        -:    4:
        1:    5:      print *,'===START OF PRF11========================'
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:    6:C --------------------------------------------------
        1:    7:      call prf1201
call    0 returned 100%
        1:    8:      call prf1202
call    0 returned 100%
        1:    9:      call prf1203
call    0 returned 100%
        -:   10:C --------------------------------------------------
        -:   11:
        -:   12:C
        1:   13:      print *,'=== END OF PRF12 ========================= '    
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
function main called 1 returned 100% blocks executed 100%
        1:   14:      end
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   15:C ---------------------------------------------PRF1201
function prf1201_ called 1 returned 100% blocks executed 78%
        1:   16:      subroutine PRF1201
        -:   17:      integer, parameter ::  N = 16,NL=1000,NIT=3
        1:   18:      integer, allocatable :: A(:),B(:),C(:),D(:)
        -:   19:      integer nloop 
        -:   20:      character*7 tname
        -:   21:                
        -:   22:cdvm$ distribute B(*)     
        -:   23:
        -:   24:cdvm$ align (I) with B(I) ::A,D
        -:   25:cdvm$ remote_group GR1
        -:   26:cdvm$ remote_group GR2
        -:   27:cdvm$ remote_group GR3
        -:   28:
        1:   29:      tname='PRF1201'
       1*:   30:      allocate (B(N),A(N),C(N),D(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
branch  9 taken 100% (fallthrough)
branch 10 taken 0%
call   11 never executed
        -:   31:      NNL=NL    
       17:   32:      call serial1(C,N,NNL)
        -:   33:      nloop=NL
        -:   34:*dvm$ parallel (i) on A(i)
       17:   35:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       16:   36:        A(i) = NL+i
       16:   37:        B(i)=NL+i
       17:   38:        D(i)=NL+i
        -:   39:      enddo
        -:   40:      it=0
        4:   41:      do it=1,NIT
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:   42:
        -:   43:cdvm$ prefetch GR1 
        -:   44:cdvm$ prefetch GR2 
        -:   45:cdvm$ prefetch GR3 
        -:   46:                                              
        -:   47:cdvm$ remote_access (GR1:A(1))
        3:   48:      ib1=A(1)
        -:   49:               
        -:   50:cdvm$ remote_access (GR2:A(N/2))
        3:   51:      ib2=A(N/2)  
        -:   52:
        -:   53:cdvm$ remote_access (GR3:A(N))
        3:   54:      ib3=A(N)
        -:   55:
        -:   56:cdvm$ remote_access (GR1:B(2))
        3:   57:      ib4=B(2)
        -:   58:               
        -:   59:cdvm$ remote_access (GR2:B(N/2-1))
        3:   60:      ib5=B(N/2-1)  
        -:   61:
        -:   62:cdvm$ remote_access (GR3:B(N-1))
        3:   63:      ib6=B(N-1)
        -:   64:
        -:   65:cdvm$ remote_access (GR1:D(3))
        3:   66:      ib7=D(3)
        -:   67:               
        -:   68:cdvm$ remote_access (GR2:D(N/2-2))
        3:   69:      ib8=D(N/2-2)  
        -:   70:
        -:   71:cdvm$ remote_access (GR3:D(N-2))
        3:   72:      ib9=D(N-2)
        -:   73:
        -:   74:      if ((ib1 .eq.C(1)).and.(ib2.eq.C(N/2)).and.(ib3.eq.C(N))
        -:   75:     * .and.(ib4 .eq.C(2)) .and.(ib5 .eq.C(N/2-1))
        -:   76:     * .and.(ib6 .eq.C(N-1))
        -:   77:     * .and.(ib7 .eq.C(3)).and.(ib8 .eq.C(N/2-2))
        3:   78:     * .and.(ib9 .eq.C(N-2))) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 100% (fallthrough)
branch  9 taken 0%
branch 10 taken 100% (fallthrough)
branch 11 taken 0%
branch 12 taken 100% (fallthrough)
branch 13 taken 0%
branch 14 taken 100% (fallthrough)
branch 15 taken 0%
branch 16 taken 100% (fallthrough)
branch 17 taken 0%
        3:   79:          call ansyes(tname)
call    0 returned 100%
        -:   80:      else
    #####:   81:          call ansno(tname)
call    0 never executed
        -:   82:      endif 
        1:   83:      if (it .eq. 2) cycle 
        -:   84:cdvm$ reset GR1
        -:   85:cdvm$ reset GR2
        -:   86:cdvm$ reset GR3
        -:   87:      enddo
       1*:   88:      deallocate (A,B,C,D)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
call   11 never executed
        1:   89:      end
        -:   90:C ---------------------------------------------PRF1202
function prf1202_ called 1 returned 100% blocks executed 78%
        1:   91:      subroutine PRF1202     
        -:   92:      integer, parameter ::  N = 16,NL=1000,NIT=3
        1:   93:      integer, allocatable :: A(:),B(:),C(:),D(:)
        -:   94:      integer nloop 
        -:   95:      character*7 tname
        -:   96:                
        -:   97:cdvm$ distribute B(*)     
        -:   98:
        -:   99:cdvm$ align (I) with B(I) ::A
        -:  100:cdvm$ remote_group GR1
        -:  101:cdvm$ remote_group GR2
        -:  102:cdvm$ remote_group GR3
        -:  103:
        1:  104:      tname='PRF1202'
       1*:  105:      allocate (B(N),A(N),C(N),D(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
branch  9 taken 100% (fallthrough)
branch 10 taken 0%
call   11 never executed
        -:  106:      NNL=NL    
       17:  107:      call serial1(C,N,NNL)
        -:  108:      nloop=NL
        -:  109:*dvm$ parallel (i) on A(i)
       17:  110:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       17:  111:        A(i) = NL+i
        -:  112:      enddo
        -:  113:      it=0
        4:  114:      do it=1,NIT
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  115:
        -:  116:cdvm$ prefetch GR1 
        -:  117:cdvm$ prefetch GR2 
        -:  118:cdvm$ prefetch GR3 
        -:  119:                                              
        -:  120:      isumc1=0
        -:  121:      isuma1=0  
        -:  122:
        -:  123:cdvm$ remote_access (GR1:A(:))                                           
       51:  124:      do i=1,N         
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       48:  125:       D(i)=A(i)
       48:  126:       isumc1=isumc1+C(i)
       51:  127:       isuma1=isuma1+D(i)
        -:  128:      enddo
        -:  129:
        -:  130:      isumc2=0
        -:  131:      isuma2=0
        -:  132:
        -:  133:      kk=2
        -:  134:      kk1=3
        -:  135:cdvm$ remote_access (GR2:A(:))                                               
       18:  136:      do i=1,N/kk-kk1
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
       15:  137:       D(i)=A(kk*i+kk1)
       15:  138:       isumc2=isumc2+C(kk*i+kk1)
       18:  139:       isuma2=isuma2+D(i)
        -:  140:      enddo
        3:  141:      if ((isumc1 .eq.isuma1) .and.(isumc2 .eq.isuma2)) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  142:          call ansyes(tname)
call    0 returned 100%
        -:  143:      else
    #####:  144:          call ansno(tname)
call    0 never executed
        -:  145:      endif 
        1:  146:      if (it .eq. 2) cycle 
        -:  147:cdvm$ reset GR1
        -:  148:cdvm$ reset GR2
        -:  149:cdvm$ reset GR3
        -:  150:
        -:  151:      enddo
       1*:  152:      deallocate (A,B,C,D)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
call   11 never executed
        1:  153:      end
        -:  154:C ---------------------------------------------PRF1203
function prf1203_ called 1 returned 100% blocks executed 84%
        1:  155:      subroutine PRF1203     
        -:  156:      integer, parameter ::  N = 16,NL=1000,NIT=3
        1:  157:      integer, allocatable :: A(:),B(:),C(:),A1(:)
        -:  158:      integer nloop 
        -:  159:      character*7 tname
        -:  160:                
        -:  161:cdvm$ distribute B(*)     
        -:  162:
        -:  163:cdvm$ align (I) with B(I) ::A,A1
        -:  164:cdvm$ remote_group GR1
        -:  165:cdvm$ remote_group GR2
        -:  166:cdvm$ remote_group GR3
        -:  167:
        1:  168:      tname='PRF1203'
       1*:  169:      allocate (B(N),A(N),C(N),A1(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
branch  9 taken 100% (fallthrough)
branch 10 taken 0%
call   11 never executed
        -:  170:      NNL=NL    
       17:  171:      call serial1(C,N,NNL)
        -:  172:      nloop=NL
        -:  173:
        -:  174:*dvm$ parallel (i) on A(i)
       17:  175:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       16:  176:        A(i) = NL+i
       17:  177:        A1(i) = NL+i
        -:  178:      enddo
        -:  179:
        -:  180:      it=0
        4:  181:      do it=1,NIT
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  182:
        -:  183:cdvm$ prefetch GR1 
        -:  184:cdvm$ prefetch GR2 
        -:  185:cdvm$ prefetch GR3 
        -:  186:
       51:  187:      nloop1=NL
        -:  188:
        -:  189:*dvm$ parallel (i) on B(i),remote_access(GR1:A(1))
       51:  190:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       51:  191:         B(i) = A(1)
        -:  192:      enddo
        -:  193:*dvm$ parallel (i) on A(i), reduction( min( nloop1 ) )
       51:  194:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
      51*:  195:          if (B(i).ne.C(1)) nloop1=min(nloop1,i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  196:      enddo
        -:  197:
       51:  198:      nloop2=NL
        -:  199:
        -:  200:*dvm$ parallel (i) on B(i),remote_access(GR1:A(N))
       51:  201:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       51:  202:         B(i) = A(N)
        -:  203:      enddo
        -:  204:*dvm$ parallel (i) on B(i), reduction( min( nloop2 ) )
       51:  205:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
      51*:  206:          if (B(i).ne.C(N)) nloop2=min(nloop2,i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  207:      enddo
       51:  208:      nloop3=NL
        -:  209:
        -:  210:*dvm$ parallel (i) on B(i),remote_access(GR2:A(N/2))
       51:  211:      do  i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       51:  212:         B(i) = A(N/2)
        -:  213:      enddo
        -:  214:*dvm$ parallel (i) on B(i), reduction( min( nloop3 ) )
       51:  215:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
      51*:  216:          if (B(i).ne.C(N/2)) nloop3=min(nloop3,i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  217:      enddo
        -:  218:               
       51:  219:      nloop4=NL
        -:  220:
        -:  221:*dvm$ parallel (i) on B(i),remote_access(GR2:A)
       51:  222:      do  i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       51:  223:         B(i) = A(i)
        -:  224:      enddo
        -:  225:*dvm$ parallel (i) on B(i), reduction( min( nloop4 ) )
       51:  226:      do  i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
      51*:  227:          if (B(i).ne.C(i)) nloop4=min(nloop4,i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  228:      enddo
        -:  229:      nloop5=NL
        -:  230:
        -:  231:*dvm$ parallel (i) on B(i),remote_access(GR3:A1(i))
       51:  232:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       51:  233:         B(i) = A1(i)
        -:  234:      enddo
        -:  235:*dvm$ parallel (i) on B(i), reduction( min( nloop ) )
        -:  236:      do i=1,N
        -:  237:          if (B(i).ne.C(i)) nloop=min(nloop,i)
        -:  238:      enddo
        -:  239:
       18:  240:      nloop6=NL
        -:  241:      kk=2
        -:  242:      kk1=3         
        -:  243:*dvm$ parallel (i) on B(i),remote_access(GR3:A(kk*i+kk1))
       18:  244:      do i=1,N/kk-kk1
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
       18:  245:         B(i) = A(kk*i+kk1)
        -:  246:      enddo
        -:  247:
        -:  248:*dvm$ parallel (i) on B(i), reduction( min( nloop6 ) )
       18:  249:      do i=1,N/kk-kk1
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
      18*:  250:          if (B(i).ne.C(kk*i+kk1)) nloop6=min(nloop6,i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  251:      enddo
        -:  252:          
        -:  253:      if ((nloop1 .eq.NL) .and.(nloop2 .eq.NL).and.(nloop2 .eq.NL)
        -:  254:     * .and.(nloop3 .eq.NL).and.(nloop4 .eq.NL).and.(nloop5 .eq.NL)
        3:  255:     * .and.(nloop6 .eq.NL)  ) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
        3:  256:          call ansyes(tname)
call    0 returned 100%
        -:  257:      else
    #####:  258:          call ansno(tname)
call    0 never executed
        -:  259:      endif 
        1:  260:      if (it .eq. 2) cycle 
        -:  261:cdvm$ reset GR1
        -:  262:cdvm$ reset GR2
        -:  263:cdvm$ reset GR3
        -:  264:
        -:  265:      enddo
       1*:  266:      deallocate (A,B,C,A1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
branch  9 taken 0% (fallthrough)
branch 10 taken 100%
call   11 never executed
        1:  267:      end
        -:  268:C -----------------------------------------------         
function serial1_ called 0 returned 0% blocks executed 0%
    #####:  269:      subroutine serial1(AR,N,NL)
        -:  270:      integer AR(N)
        -:  271:      integer NL 
      51*:  272:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
branch  4 never executed (fallthrough)
branch  5 never executed
branch  6 taken 6% (fallthrough)
branch  7 taken 94%
      51*:  273:        AR(i) = NL+i
        -:  274:      enddo                   
    #####:  275:      end 
        -:  276:
        -:  277:
function ansyes_ called 9 returned 100% blocks executed 100%
        9:  278:      subroutine ansyes(name)
        -:  279:      character*7 name
        9:  280:      print *,name,'  -  complete'
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        9:  281:      end
function ansno_ called 0 returned 0% blocks executed 0%
    #####:  282:      subroutine ansno(name)
        -:  283:      character*7 name
    #####:  284:      print *,name,'  -  ***error'
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  285:      end
