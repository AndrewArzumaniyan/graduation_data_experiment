        -:    0:Source:results/1d/red12/red12.f
        -:    0:Graph:./results\1d\red12\red12.gcno
        -:    0:Data:./results\1d\red12\red12.gcda
        -:    0:Runs:1
function MAIN__ called 1 returned 100% blocks executed 100%
        1:    1:      program RED12
        -:    2:
        -:    3:c    TESTING OF THE REDUCTION CLAUSE .       
        -:    4:c    REDUCTION OPERATION : SUM.PRODUCT,MAX,MIN,AND,OR, EQV,
        -:    5:C    NEQV,MAXLOC,MINLOC AND THEIR COMBINATION ARE EXECUTED
        -:    6:c    FOR DISTRIBUTED ARRAY A(N). 
        -:    7:
        1:    8:      print *,'===START OF RED12========================'
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:    9:C --------------------------------------------------
        1:   10:      call red1201
call    0 returned 100%
        -:   11:C --------------------------------------------------
        1:   12:      call red1202
call    0 returned 100%
        -:   13:C --------------------------------------------------
        1:   14:      call red1203
call    0 returned 100%
        -:   15:C -------------------------------------------------
        1:   16:      call red1204
call    0 returned 100%
        -:   17:C -------------------------------------------------
        1:   18:      call red1205
call    0 returned 100%
        -:   19:C -------------------------------------------------
        1:   20:      call red1206
call    0 returned 100%
        -:   21:C --------------------------------------------------
        1:   22:      call red1207
call    0 returned 100%
        -:   23:C --------------------------------------------------
        1:   24:      call red1208
call    0 returned 100%
        -:   25:C --------------------------------------------------
        1:   26:      call red1209
call    0 returned 100%
        -:   27:C -------------------------------------------------
        1:   28:      call red1210
call    0 returned 100%
        -:   29:C -------------------------------------------------
        1:   30:      call red1211
call    0 returned 100%
        -:   31:C -------------------------------------------------
        1:   32:      call red1212
call    0 returned 100%
        -:   33:C ------------------------------------------------- 
        1:   34:      call red1213
call    0 returned 100%
        -:   35:C --------------------------------------------------
        1:   36:      call red1214
call    0 returned 100%
        -:   37:C --------------------------------------------------
        1:   38:      call red1215
call    0 returned 100%
        -:   39:C -------------------------------------------------
        1:   40:      call red1216
call    0 returned 100%
        -:   41:C -------------------------------------------------
        -:   42:
        -:   43:C
        -:   44:C
        1:   45:      print *,'=== END OF RED12 ========================= '    
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
function main called 1 returned 100% blocks executed 100%
        1:   46:      end
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   47:
        -:   48:C ----------------------------------------------------RED1201
function red1201_ called 1 returned 100% blocks executed 82%
        1:   49:      subroutine RED1201
        -:   50:      integer, parameter :: N = 16,NL=1000
        -:   51:      character*7 tname
        1:   52:      integer, allocatable :: A(:),C(:)
        -:   53:      integer isum1,isumt1 
        -:   54:      
        -:   55:!dvm$ distribute A(*)   
        -:   56:
        1:   57:      tname='RED1201'
       1*:   58:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:   59:      NNL=NL 
        -:   60:      NN=N
       17:   61:      call sersum1(C,NN,NNL,isum1)
       17:   62:      isumt1 = 0
        -:   63:
        -:   64:!dvm$ actual(isumt1)
        -:   65:!dvm$ region local(A)
        -:   66:!dvm$ parallel (i) on A(i)
       17:   67:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       17:   68:         A(i) = i+NL
        -:   69:      enddo
        -:   70:  
        -:   71:!dvm$ parallel (i) on A(i), reduction( sum( isumt1 ) )
       17:   72:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:   73:         isumt1 = isumt1+A(i)
        -:   74:      enddo
        -:   75:!dvm$ end region   
        -:   76:!dvm$ get_actual(isumt1) 
        -:   77:     
        1:   78:      if (isum1 .eq.isumt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   79:          call ansyes(tname)
call    0 returned 100%
        -:   80:      else
    #####:   81:          call ansno(tname)
call    0 never executed
        -:   82:      endif 
       1*:   83:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:   84:
        1:   85:      end
        -:   86:C -----------------------------------------------------RED1202
function red1202_ called 1 returned 100% blocks executed 82%
        1:   87:      subroutine RED1202
        -:   88:      integer, parameter :: N = 16, NL=1000
        -:   89:      character*7 tname
        1:   90:      integer, allocatable :: A(:),C(:)
        -:   91:      integer iprod1,iprodt1 
        -:   92:                 
        -:   93:!dvm$ distribute A(*)    
        -:   94:      
        1:   95:      tname='RED1202'
       1*:   96:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:   97:      NNL=NL
        -:   98:      NN=N
       17:   99:      call serprod1(C,NN,NNL,iprod1)
       17:  100:      iprodt1 = 1
        -:  101:
        -:  102:!dvm$ actual(iprodt1)
        -:  103:!dvm$ region local(A)
        -:  104:!dvm$ parallel (i) on A(i)
       17:  105:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       17:  106:         A(i) = i+NL
        -:  107:      enddo
        -:  108:  
        -:  109:!dvm$ parallel (i) on A(i), reduction( product( iprodt1 ) )
       17:  110:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  111:         iprodt1 = iprodt1*A(i)
        -:  112:      enddo
        -:  113:!dvm$ end region   
        -:  114:!dvm$ get_actual(iprodt1) 
        -:  115: 
        1:  116:      if (iprod1 .eq.iprodt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  117:          call ansyes(tname)
call    0 returned 100%
        -:  118:      else
    #####:  119:          call ansno(tname)
call    0 never executed
        -:  120:      endif 
       1*:  121:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  122: 
        1:  123:      end
        -:  124:C ----------------------------------------------------RED1203
function red1203_ called 1 returned 100% blocks executed 78%
        1:  125:      subroutine RED1203
        -:  126:      integer, parameter :: N = 16,NL=1000
        -:  127:      character*7 tname
        1:  128:      integer, allocatable :: A(:),C(:)
        -:  129:      integer imax1,imaxt1 ,ni,imin
        -:  130:                       
        -:  131:!dvm$ distribute A(*)     
        -:  132:
        1:  133:      tname='RED1203'
       1*:  134:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  135:     
        -:  136:!dvm$ parallel (i) on A(i)
       17:  137:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  138:         A(i) = i+NL
        -:  139:      enddo
        -:  140:
        1:  141:      ni=N/2
        1:  142:      A(ni)=N+1+NL
        1:  143:      imax1=N+1+NL
        -:  144:
        -:  145:!dvm$ remote_access (A(1))
        1:  146:      imaxt1=A(1)  
        -:  147:
        -:  148:!dvm$ actual(imaxt1)
        -:  149:!dvm$ region
        -:  150:!dvm$ parallel (i) on A(i), reduction( max( imaxt1 ) )
       16:  151:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  152:         if (A(i).GT.imaxt1) imaxt1=A(i)
        -:  153:      enddo
        -:  154:!dvm$ end region   
        -:  155:!dvm$ get_actual(imaxt1) 
        -:  156:
        1:  157:      if (imax1 .eq.imaxt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  158:          call ansyes(tname)
call    0 returned 100%
        -:  159:      else
    #####:  160:          call ansno(tname)
call    0 never executed
        -:  161:      endif 
       1*:  162:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  163:      
        1:  164:      end
        -:  165:    
        -:  166:C ----------------------------------------------------RED1204
function red1204_ called 1 returned 100% blocks executed 78%
        1:  167:      subroutine RED1204
        -:  168:      integer, parameter :: N = 16,NL=1000
        -:  169:      character*7 tname
        1:  170:      integer, allocatable :: A(:),C(:)
        -:  171:      integer imax1,imaxt1 ,ni,imin
        -:  172:                       
        -:  173:!dvm$ distribute A(*)     
        -:  174:
        1:  175:      tname='RED1204'
       1*:  176:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  177: 
        -:  178:!dvm$ parallel (i) on A(i)
       17:  179:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  180:         A(i) = i+NL
        -:  181:      enddo
        -:  182:
        1:  183:      ni=N/2
        1:  184:      A(ni)=-(N+1+NL)
        1:  185:      imin1=-(N+1+NL)
        -:  186:
        -:  187:!dvm$ remote_access (A(1))      
        1:  188:      imint1=A(1)
        -:  189:
        -:  190:!dvm$ actual(imint1)
        -:  191:!dvm$ region
        -:  192:!dvm$ parallel (i) on A(i), reduction( min( imint1 ) )
       16:  193:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  194:         if (A(i).LT.imint1) imint1=A(i)
        -:  195:      enddo
        -:  196:!dvm$ end region   
        -:  197:!dvm$ get_actual(imint1) 
        -:  198:
        1:  199:      if (imin1 .eq.imint1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  200:          call ansyes(tname)
call    0 returned 100%
        -:  201:      else
    #####:  202:          call ansno(tname)
call    0 never executed
        -:  203:      endif
       1*:  204:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  205: 
        1:  206:      end
        -:  207:C ----------------------------------------------------RED1205
function red1205_ called 1 returned 100% blocks executed 78%
        1:  208:      subroutine RED1205
        -:  209:      integer, parameter :: N = 16
        -:  210:      real, parameter :: NL=1000.
        -:  211:      character*7 tname
        1:  212:      real, allocatable :: A(:),C(:)
        -:  213:      integer ni
        -:  214:      real imax1,imaxt1                  
        -:  215:!dvm$ distribute A(*)     
        -:  216:
        1:  217:      tname='RED1205'
       1*:  218:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  219:     
        -:  220:!dvm$ parallel (i) on A(i)
       17:  221:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  222:         A(i) = i+NL
        -:  223:      enddo
        -:  224:
        1:  225:      ni=N/2
        1:  226:      A(ni)=N+1.+NL
        1:  227:      imax1=N+1.+NL
        -:  228:
        -:  229:!dvm$ remote_access (A(1))
        1:  230:      imaxt1=A(1)  
        -:  231:
        -:  232:!dvm$ actual(imaxt1)
        -:  233:!dvm$ region
        -:  234:!dvm$ parallel (i) on A(i), reduction( max( imaxt1 ) )
       16:  235:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  236:         if (A(i).GT.imaxt1) imaxt1=A(i)
        -:  237:      enddo
        -:  238:!dvm$ end region   
        -:  239:!dvm$ get_actual(imaxt1) 
        -:  240:
        1:  241:      if (imax1 .eq.imaxt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  242:          call ansyes(tname)
call    0 returned 100%
        -:  243:      else
    #####:  244:          call ansno(tname)
call    0 never executed
        -:  245:      endif 
       1*:  246:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  247:      
        1:  248:      end
        -:  249:                    
        -:  250:C -----------------------------------------------------RED1206
function red1206_ called 1 returned 100% blocks executed 82%
        1:  251:      subroutine RED1206
        -:  252:      integer, parameter :: N = 8
        -:  253:      real, parameter :: NL=1.
        -:  254:      character*7 tname
        1:  255:      real, allocatable :: A(:),C(:)
        -:  256:      real iprod1,iprodt1 
        -:  257:      real NNl
        -:  258:                 
        -:  259:!dvm$ distribute A(*)     
        -:  260:
        1:  261:      tname='RED1206'
       1*:  262:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  263:      NNL=NL
        -:  264:      NN=N
        9:  265:      call serprodr1(C,NN,NNL,iprod1)
        9:  266:      iprodt1 = 1.
        -:  267:
        -:  268:!dvm$ actual(iprodt1)
        -:  269:!dvm$ region local(A)
        -:  270:!dvm$ parallel (i) on A(i)
        9:  271:      do i=1,N
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        9:  272:         A(i) = i+NL
        -:  273:      enddo
        -:  274:  
        -:  275:!dvm$ parallel (i) on A(i), reduction( product( iprodt1 ) )
        9:  276:      do i=1,N
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
        9:  277:         iprodt1 = iprodt1*A(i)
        -:  278:      enddo
        -:  279:!dvm$ end region   
        -:  280:!dvm$ get_actual(iprodt1) 
        -:  281: 
        1:  282:      if (iprod1 .eq.iprodt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  283:          call ansyes(tname)
call    0 returned 100%
        -:  284:      else
    #####:  285:          call ansno(tname)
call    0 never executed
        -:  286:      endif 
       1*:  287:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  288: 
        1:  289:      end
        -:  290:
        -:  291:C -----------------------------------------------------RED1207
function red1207_ called 1 returned 100% blocks executed 84%
        1:  292:      subroutine RED1207
        -:  293:      integer, parameter :: N = 16
        -:  294:      character*7 tname
        1:  295:      logical, allocatable :: A(:),C(:)
        -:  296:      logical land1,landt1,leqv1,lneqv1,lor1
        -:  297:
        -:  298:!dvm$ distribute A(*)     
        -:  299:
        1:  300:      tname='RED1207'
       1*:  301:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  302:      NN=N     
        1:  303:      call serlog1(C,NN,land1,lor1,leqv1,lneqv1)
        -:  304:                                    
        -:  305:               
        -:  306:!dvm$ parallel (i) on A(i)
        1:  307:      do i=1,N,2
call    0 returned 100%
        8:  308:         A(i) = .true.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  309:      enddo
        -:  310:
        -:  311:!dvm$ parallel (i) on A(i+1)
        8:  312:      do i=1,N-1,2
        8:  313:         A(i+1)=.false.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  314:      enddo
        -:  315:
        -:  316:!dvm$ remote_access (A(1))
        1:  317:      landt1 = A(1)
        -:  318:
        -:  319:!dvm$ actual(landt1)
        -:  320:!dvm$ region
        -:  321:!dvm$ parallel (i) on A(i), reduction( AND( landt1 ) )
       16:  322:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       31:  323:         landt1 = landt1 .and.A(i)
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  324:      enddo
        -:  325:!dvm$ end region   
        -:  326:!dvm$ get_actual(landt1) 
        -:  327:      
        -:  328:
        1:  329:      if (land1 .eqv.landt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  330:          call ansyes(tname)
call    0 returned 100%
        -:  331:      else
    #####:  332:          call ansno(tname)
call    0 never executed
        -:  333:      endif 
       1*:  334:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  335: 
        1:  336:      end
        -:  337:C -----------------------------------------------------RED1208
function red1208_ called 1 returned 100% blocks executed 80%
        1:  338:      subroutine RED1208
        -:  339:      integer, parameter :: N = 16
        -:  340:      character*7 tname
        1:  341:      logical, allocatable :: A(:),C(:)
        -:  342:      logical land1,landt1,lor1,lort1,leqv1,lneqv1
        -:  343:
        -:  344:!dvm$ distribute A(*)     
        -:  345:
        1:  346:      tname='RED1208'
       1*:  347:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  348:      NN=N
        1:  349:      call serlog1(C,NN,land1,lor1,leqv1,lneqv1)
        -:  350:                                    
        -:  351:!dvm$ parallel (i) on A(i)
        1:  352:      do i=1,N,2
call    0 returned 100%
        8:  353:         A(i) = .true.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  354:      enddo
        -:  355:
        -:  356:!dvm$ parallel (i) on A(i+1)
        8:  357:      do i=1,N-1,2
        8:  358:         A(i+1)=.false.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  359:      enddo
        -:  360:
        -:  361:!dvm$ remote_access (A(1))
        1:  362:      lort1 = A(1)
        -:  363:
        -:  364:!dvm$ actual(lort1)
        -:  365:!dvm$ region
        -:  366:!dvm$ parallel (i) on A(i), reduction( OR( lort1 ) )
       16:  367:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
      31*:  368:         lort1 = lort1 .or.A(i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  369:      enddo
        -:  370:!dvm$ end region   
        -:  371:!dvm$ get_actual(lort1) 
        -:  372:      
        1:  373:      if (lor1 .eqv.lort1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  374:          call ansyes(tname)
call    0 returned 100%
        -:  375:      else
    #####:  376:          call ansno(tname)
call    0 never executed
        -:  377:      endif 
       1*:  378:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  379: 
        1:  380:      end
        -:  381:C -----------------------------------------------------RED1209
function red1209_ called 1 returned 100% blocks executed 82%
        1:  382:      subroutine RED1209
        -:  383:      integer, parameter :: N = 16     
        -:  384:      character*7 tname
        1:  385:      logical, allocatable :: A(:),C(:)
        -:  386:      logical land1,landt1,lor1,leqv1,leqvt1,lneqv1
        -:  387:
        -:  388:!dvm$ distribute A(*)     
        -:  389:
        1:  390:      tname='RED1209'
       1*:  391:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  392:      NN=N
        1:  393:      call serlog1(C,NN,land1,lor1,leqv1,lneqv1)
        -:  394:               
        -:  395:!dvm$ parallel (i) on A(i)
        1:  396:      do i=1,N,2
call    0 returned 100%
        8:  397:         A(i) = .true.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  398:      enddo
        -:  399:
        -:  400:!dvm$ parallel (i) on A(i+1)
        8:  401:      do i=1,N-1,2
        8:  402:         A(i+1)=.false.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  403:      enddo
        -:  404:
        -:  405:!dvm$ remote_access (A(1))
        1:  406:      leqvt1 = A(1)
        -:  407:
        -:  408:!dvm$ actual(leqvt1)
        -:  409:!dvm$ region
        -:  410:!dvm$ parallel (i) on A(i), reduction( EQV( leqvt1 ) )
       16:  411:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  412:         leqvt1 = leqvt1 .eqv.A(i)
        -:  413:      enddo
        -:  414:!dvm$ end region   
        -:  415:!dvm$ get_actual(leqvt1) 
        -:  416:
        1:  417:      if (leqv1 .eqv.leqvt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  418:          call ansyes(tname)
call    0 returned 100%
        -:  419:      else
    #####:  420:          call ansno(tname)
call    0 never executed
        -:  421:      endif  
       1*:  422:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  423:
        1:  424:      end
        -:  425:C -----------------------------------------------------RED1210
function red1210_ called 1 returned 100% blocks executed 82%
        1:  426:      subroutine RED1210
        -:  427:      integer, parameter :: N = 16
        -:  428:      character*7 tname
        1:  429:      logical, allocatable :: A(:),C(:)
        -:  430:      logical land1,landt1,lor1,leqv1,lneqv1,lneqvt1
        -:  431:
        -:  432:!dvm$ distribute A(*)    
        -:  433:
        1:  434:      tname='RED1210'
       1*:  435:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  436:      NN=N
        1:  437:      call serlog1(C,NN,land1,lor1,leqv1,lneqv1)
        -:  438:               
        -:  439:!dvm$ parallel (i) on A(i)
        1:  440:      do i=1,N,2
call    0 returned 100%
        8:  441:         A(i) = .true.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  442:      enddo
        -:  443:
        -:  444:!dvm$ parallel (i) on A(i+1)
        8:  445:      do i=1,N-1,2
        8:  446:         A(i+1)=.false.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  447:      enddo
        -:  448:
        -:  449:!dvm$ remote_access (A(1))
        1:  450:      lneqvt1 = A(1)
        -:  451:
        -:  452:!dvm$ actual(lneqvt1)
        -:  453:!dvm$ region
        -:  454:!dvm$ parallel (i) on A(i), reduction( NEQV( lneqvt1 ) )
       16:  455:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  456:         lneqvt1 = lneqvt1 .neqv.A(i)
        -:  457:      enddo
        -:  458:!dvm$ end region   
        -:  459:!dvm$ get_actual(lneqvt1) 
        -:  460:
        1:  461:      if (lneqv1 .eqv.lneqvt1) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  462:          call ansyes(tname)
call    0 returned 100%
        -:  463:      else
    #####:  464:          call ansno(tname)
call    0 never executed
        -:  465:      endif 
       1*:  466:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  467: 
        1:  468:      end
        -:  469:
        -:  470:C ----------------------------------------------------RED1211
        -:  471:
function red1211_ called 1 returned 100% blocks executed 80%
        1:  472:      subroutine RED1211
        -:  473:      integer, parameter :: N = 16,NL=1000
        -:  474:      character*7 tname
        1:  475:      integer, allocatable :: A(:),C(:)
        -:  476:      integer imax1,imaxt1 ,ni,imin,lit
        -:  477:                       
        -:  478:!dvm$ distribute A(*)     
        -:  479:
        1:  480:      tname='RED1211'
       1*:  481:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  482:     
        -:  483:!dvm$ parallel (i) on A(i)
       17:  484:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  485:         A(i) = i+NL
        -:  486:      enddo
        1:  487:      ni=N/2
        1:  488:      A(ni)=N+1+NL
        1:  489:      imax1=N+1+NL
        -:  490:
        -:  491:!dvm$ remote_access (A(1))
        1:  492:      imaxt1=A(1)  
        -:  493:
        1:  494:      lit=1
        1:  495:      it1=0
        -:  496:
        -:  497:!dvm$ actual(imaxt1)
        -:  498:!dvm$ region
        -:  499:!dvm$ parallel (i) on A(i), reduction( maxloc( imaxt1,it1,1 ) )
       16:  500:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  501:         if (A(i).GT.imaxt1)then
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
        7:  502:         imaxt1=A(i)
        7:  503:         it1=i
        -:  504:         endif
        -:  505:      enddo
        -:  506:!dvm$ end region   
        -:  507:!dvm$ get_actual(imaxt1,it1,lit) 
        -:  508:
        1:  509:      if ((imax1 .eq.imaxt1) .and. (it1.eq.ni)) then
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  510:          call ansyes(tname)
call    0 returned 100%
        -:  511:      else
    #####:  512:          call ansno(tname)
call    0 never executed
        -:  513:      endif 
       1*:  514:      deallocate (A,C)      
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  515:
        1:  516:      end
        -:  517:    
        -:  518: 
        -:  519:C ----------------------------------------------------RED1212
function red1212_ called 1 returned 100% blocks executed 80%
        1:  520:      subroutine RED1212
        -:  521:      integer, parameter :: N = 16,NL=1000
        -:  522:      character*7 tname
        1:  523:      integer, allocatable :: A(:),C(:)
        -:  524:      integer imax1,imaxt1 ,ni,imin,lit
        -:  525:                       
        -:  526:!dvm$ distribute A(*)     
        -:  527:
        1:  528:      tname='RED1212'
       1*:  529:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  530:     
        -:  531:!dvm$ parallel (i) on A(i)
       17:  532:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  533:         A(i) = i+NL
        -:  534:      enddo
        1:  535:      ni=N/2
        1:  536:      A(ni)=-(N+1+NL)
        1:  537:      imin1=-(N+1+NL)
        -:  538:
        -:  539:!dvm$ remote_access (A(1))
        1:  540:      imint1=A(1)  
        -:  541:
        1:  542:      lit=1
        1:  543:      it1=0
        -:  544:
        -:  545:!dvm$ actual(imaxt1)
        -:  546:!dvm$ region
        -:  547:!dvm$ parallel (i) on A(i), reduction( minloc( imint1,it1,1 ) )
       16:  548:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  549:         if (A(i).LT.imint1)then
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        1:  550:         imint1=A(i)
        1:  551:         it1=i
        -:  552:         endif
        -:  553:      enddo
        -:  554:!dvm$ end region   
        -:  555:!dvm$ get_actual(imint1,it1,lit) 
        -:  556:
        1:  557:      if ((imin1 .eq.imint1) .and. (it1.eq.ni)) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  558:          call ansyes(tname)
call    0 returned 100%
        -:  559:      else
    #####:  560:          call ansno(tname)
call    0 never executed
        -:  561:      endif 
       1*:  562:      deallocate (A,C)      
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  563:
        1:  564:      end
        -:  565:
        -:  566:
        -:  567:C ----------------------------------------------------RED1213
function red1213_ called 1 returned 100% blocks executed 79%
        1:  568:      subroutine RED1213
        -:  569:      integer, parameter :: N = 16,NL=1000
        -:  570:      character*7 tname
        1:  571:      integer, allocatable :: A(:),C(:)
        -:  572:      integer isum1,isumt1 
        -:  573:      integer imax1,imaxt1 ,ni,imin1,imint1
        -:  574:                 
        -:  575:!dvm$ distribute A(*)     
        -:  576:
        1:  577:      tname='RED1213'
       1*:  578:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  579:      NNL=NL 
        1:  580:      NN=N
        1:  581:      call sersum1m(C,NN,NNL,isum1)
        -:  582:
        -:  583:!dvm$ parallel (i) on A(i)
       17:  584:      do i=1,N
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
       17:  585:         A(i) = i+NL
        -:  586:      enddo
        -:  587:
        1:  588:      ni=N/2-1
        1:  589:      A(ni)=N+1+NL
        1:  590:      imax1=N+1+NL
        -:  591:
        -:  592:!dvm$ remote_access (A(1))
        1:  593:      imaxt1=A(1)  
        -:  594:
        1:  595:      ni=N/2
        1:  596:      A(ni)=-(N+1+NL)
        1:  597:      imin1=-(N+1+NL)
        -:  598:
        -:  599:!dvm$ remote_access (A(1))      
        1:  600:      imint1=A(1)
        -:  601:  
        1:  602:      isumt1 = 0
        -:  603:
        -:  604:!dvm$ actual(isumt1,imaxt1, imint1)
        -:  605:!dvm$ region
        -:  606:!dvm$ parallel (i) on A(i), reduction( sum( isumt1 ),
        -:  607:!dvm$*max( imaxt1 ),min( imint1 ) )
       17:  608:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  609:         isumt1 = isumt1+A(i)
       16:  610:         if (A(i).GT.imaxt1) imaxt1=A(i)
       17:  611:         if (A(i).LT.imint1) imint1=A(i)
        -:  612:      enddo
        -:  613:!dvm$ end region   
        -:  614:!dvm$ get_actual(isumt1,imaxt1, imint1)
        -:  615:
        -:  616:c      print *,isumt1,isum1
        -:  617:c      print *,imaxt1,imax1
        -:  618:c      print *,imint1,imin1
        -:  619:      if ((isum1 .eq.isumt1) .and.(imax1 .eq.imaxt1)
        1:  620:     *   .and.(imin1 .eq.imint1))   then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  621:          call ansyes(tname)
call    0 returned 100%
        -:  622:      else
    #####:  623:          call ansno(tname)
call    0 never executed
        -:  624:      endif 
       1*:  625:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  626:
        1:  627:      end
        -:  628:
        -:  629:C -----------------------------------------------------RED1214
function red1214_ called 1 returned 100% blocks executed 83%
        1:  630:      subroutine RED1214
        -:  631:      integer, parameter :: N = 16 ,NL=1
        -:  632:      character*7 tname
        1:  633:      integer, allocatable :: A(:),C(:)
        -:  634:      integer iprod1,iprodt1 
        1:  635:      logical, allocatable :: B(:),CL(:)
        -:  636:      logical land1,landt1,lor1,leqv1,lneqv1
        -:  637:                 
        -:  638:!dvm$ distribute A(*)     
        -:  639:!dvm$ align B(I) with A(I)
        -:  640:      
        1:  641:      tname='RED1214'
       1*:  642:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
       1*:  643:      allocate (B(N),CL(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  644:      NNL=NL
        1:  645:      NN=N
        2:  646:      call serprod1(C,NN,NNL,iprod1)
        1:  647:      call serlog1(CL,NN,land1,lor1,leqv1,lneqv1)  
        -:  648:               
        -:  649:!dvm$ parallel (i) on B(i)
        1:  650:      do i=1,N,2
call    0 returned 100%
        8:  651:         B(i) = .true.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  652:      enddo
        -:  653:
        -:  654:!dvm$ parallel (i) on B(i+1)
        8:  655:      do i=1,N-1,2
        8:  656:         B(i+1)=.false.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  657:      enddo
        -:  658:
        -:  659:!dvm$ remote_access (B(1))
        1:  660:      landt1 = B(1)
        1:  661:      iprodt1 = 1
        -:  662:
        -:  663:!dvm$ actual(iprodt1,landt1)
        -:  664:!dvm$ region local(A)
        -:  665:!dvm$ parallel (i) on A(i)
       17:  666:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       17:  667:         A(i) = i+NL
        -:  668:      enddo
        -:  669:  
        -:  670:!dvm$ parallel (i) on A(i), reduction( product( iprodt1 ),
        -:  671:!dvm$* and(landt1))
       17:  672:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  673:         iprodt1 = iprodt1*A(i)
       17:  674:         if (i.eq.1) then 
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        -:  675:!         landt1=B(1)
        -:  676:         else
       15:  677:         landt1 = landt1 .and.B(i)
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  678:         endif
        -:  679:      enddo
        -:  680:!dvm$ end region   
        -:  681:!dvm$ get_actual(iprodt1,landt1)
        -:  682:
        -:  683: 
        -:  684:      if ((iprod1 .eq.iprodt1)
        1:  685:     *.and. (land1 .eqv.landt1)) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  686:          call ansyes(tname)
call    0 returned 100%
        -:  687:      else
    #####:  688:          call ansno(tname)
call    0 never executed
        -:  689:      endif 
       1*:  690:      deallocate (B,CL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       1*:  691:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  692: 
        1:  693:      end
        -:  694:
        -:  695:
        -:  696:C ----------------------------------------------------RED1215
function red1215_ called 1 returned 100% blocks executed 83%
        1:  697:      subroutine RED1215
        -:  698:      integer, parameter :: N = 16,NL=1000
        -:  699:      character*7 tname
        1:  700:      integer, allocatable :: A(:),C(:)
        -:  701:      integer imax1,imaxt1 ,ni,imin1,imint1,it1,it2
        -:  702:      integer imaxloct1,iminloct1,lit          
        -:  703:!dvm$ distribute A(*)     
        -:  704:
        1:  705:      tname='RED1215'
       1*:  706:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  707:      
        -:  708:!dvm$ parallel (i) on A(i)
       17:  709:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  710:         A(i) = i+NL
        -:  711:      enddo
        -:  712:
        1:  713:      ni=N/2-1
        1:  714:      A(ni)=N+1+NL
        1:  715:      imax1=N+1+NL
        -:  716:
        -:  717:!dvm$ remote_access (A(1))
        1:  718:      imaxt1=A(1)  
        -:  719:
        1:  720:      imaxloct1=imaxt1
        1:  721:      ni1=N/2
        1:  722:      A(ni1)=-(N+1+NL)
        1:  723:      imin1=-(N+1+NL)
        -:  724:
        -:  725:!dvm$ remote_access (A(1))      
        1:  726:      imint1=A(1)
        -:  727:
        1:  728:      iminloct1=imint1
        1:  729:      lit=1
        1:  730:      it1=0
        1:  731:      it2=0
        -:  732:
        -:  733:!dvm$ actual(imaxt1,imaxloct1,it1,lit,iminloct1,it2,lit)
        -:  734:!dvm$ region
        -:  735:!dvm$ parallel (i) on A(i), reduction( max( imaxt1 ),
        -:  736:!dvm$*maxloc( imaxloct1,it1,1 ),minloc( iminloct1,it2,1 ) )
       17:  737:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  738:         if (A(i).GT.imaxt1) imaxt1 =A(i)
       16:  739:         if (A(i).GT.imaxloct1) then
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
        6:  740:         imaxloct1=A(i)
        6:  741:         it1=i
        -:  742:         endif
       17:  743:         if (A(i).LT.iminloct1) then
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        1:  744:         iminloct1=A(i)
        1:  745:         it2=i
        -:  746:         endif
        -:  747:      enddo
        -:  748:!dvm$ end region   
        -:  749:!dvm$ get_actual(imaxt1,imaxloct1,it1,iminloct1,it2) 
        -:  750:
        -:  751:      if ((imaxloct1.eq.imax1).and.(iminloct1.eq.imin1)
        -:  752:     *.and.(imaxt1.eq.imaxloct1).and.(it1.eq.ni)
        1:  753:     *.and.(it2.eq.ni1) )   then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        1:  754:          call ansyes(tname)
call    0 returned 100%
        -:  755:      else
    #####:  756:          call ansno(tname)
call    0 never executed
        -:  757:      endif 
       1*:  758:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  759:
        1:  760:      end
        -:  761:
        -:  762:
        -:  763:C ----------------------------------------------------RED1216
function red1216_ called 1 returned 100% blocks executed 83%
        1:  764:      subroutine RED1216
        -:  765:      integer, parameter :: N = 16,NL=1000
        -:  766:      character*7 tname
        1:  767:      real, allocatable :: A(:),C(:)
        -:  768:      real isum1,isumt1
        -:  769:      real imax1,imaxt1 ,imin1,imint1
        -:  770:      real imaxloct1,iminloct1,NNL
        -:  771:      integer it1,it2,ni,ni1,lit
        -:  772:          
        -:  773:!dvm$ distribute A(*)     
        -:  774:
        1:  775:      tname='RED1216'
       1*:  776:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  777:      NNL=NL
        1:  778:      NN=N 
        1:  779:      call sersum1mr(C,NN,NNL,isum1)
        -:  780:!dvm$ parallel (i) on A(i)
       17:  781:      do i=1,N
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
       17:  782:         A(i) = i+NL
        -:  783:      enddo
        -:  784:
        1:  785:      ni=N/2-1
        1:  786:      A(ni)=N+1+NL
        1:  787:      imax1=N+1+NL
        -:  788:
        -:  789:!dvm$ remote_access (A(1))
        1:  790:      imaxt1=A(1)  
        -:  791:
        1:  792:      imaxloct1=imaxt1
        1:  793:      ni1=N/2
        1:  794:      A(ni1)=-(N+1+NL)
        1:  795:      imin1=-(N+1+NL)
        -:  796:
        -:  797:!dvm$ remote_access (A(1))      
        1:  798:      imint1=A(1)
        -:  799:
        1:  800:      iminloct1=imint1
        1:  801:      isumt1 = 0.
        1:  802:      lit=1
        1:  803:      it1=0
        1:  804:      it2=0
        -:  805:
        -:  806:!dvm$ actual(isumt1,imaxloct1,it1,lit,iminloct1,it2)
        -:  807:!dvm$ region
        -:  808:!dvm$ parallel (i) on A(i), reduction( sum( isumt1 ),
        -:  809:!dvm$*maxloc( imaxloct1,it1,1 ),minloc( iminloct1,it2,1 ) )
       17:  810:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  811:         isumt1 = isumt1+A(i)
       16:  812:         if (A(i).GT.imaxloct1) then
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
        6:  813:         imaxloct1=A(i)
        6:  814:         it1=i
        -:  815:         endif
       17:  816:         if (A(i).LT.iminloct1) then
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        1:  817:         iminloct1=A(i)
        1:  818:         it2=i
        -:  819:         endif
        -:  820:     
        -:  821:
        -:  822:      enddo
        -:  823:!dvm$ end region   
        -:  824:!dvm$ get_actual(isumt1,imaxloct1,it1,iminloct1,it2) 
        -:  825:         
        -:  826:      if ((imaxloct1.eq.imax1).and.(iminloct1.eq.imin1)
        -:  827:     *.and.(isumt1.eq.isum1).and.(it1.eq.ni)
        1:  828:     *.and.(it2.eq.ni1) )   then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        1:  829:          call ansyes(tname)
call    0 returned 100%
        -:  830:      else
    #####:  831:          call ansno(tname)
call    0 never executed
        -:  832:      endif 
       1*:  833:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  834:
        1:  835:      end
        -:  836:
        -:  837:C -----------------------------------------------------
        -:  838:
function sersum1_ called 0 returned 0% blocks executed 0%
    #####:  839:      subroutine sersum1(AR,N,NL,S)
        -:  840:      integer AR(N)
        -:  841:      integer S,NL
        -:  842:
      17*:  843:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
      17*:  844:         AR(i) = i+NL
        -:  845:      enddo
    #####:  846:      S=0
      17*:  847:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
      17*:  848:         s = s+ AR(i)
        -:  849:      enddo
    #####:  850:      end   
        -:  851:   
function sersum1m_ called 1 returned 100% blocks executed 100%
        1:  852:      subroutine sersum1m(AR,N,NL,S)
        -:  853:      integer AR(N)
        -:  854:      integer S,NL
       17:  855:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  856:         AR(i) = i+NL
        -:  857:      enddo
        1:  858:      ni=N/2-1
        1:  859:      AR(ni)=N+1+NL
        1:  860:      ni=N/2
        1:  861:      AR(ni)=-(N+1+NL)
        1:  862:      S=0
       17:  863:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  864:         s = s+ AR(i)
        -:  865:      enddo
        1:  866:      end   
        -:  867:
function sersum1mr_ called 1 returned 100% blocks executed 100%
        1:  868:      subroutine sersum1mr(AR,N,NL,S)
        -:  869:      real AR(N)
        -:  870:      real S,NL
       17:  871:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  872:         AR(i) = i+NL
        -:  873:      enddo
        1:  874:      ni=N/2-1
        1:  875:      AR(ni)=N+1+NL
        1:  876:      ni=N/2
        1:  877:      AR(ni)=-(N+1+NL)
        1:  878:      S=0.
       17:  879:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  880:         S = S+ AR(i)
        -:  881:      enddo
        1:  882:      end  
        -:  883:  
function serprod1_ called 0 returned 0% blocks executed 0%
       1*:  884:      subroutine serprod1(AR,N,NL,P)
        -:  885:      integer AR(N)
        -:  886:      integer P,NL
      34*:  887:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
branch  2 never executed (fallthrough)
branch  3 never executed
branch  4 taken 6% (fallthrough)
branch  5 taken 94%
      34*:  888:         AR(i) = i+NL
        -:  889:      enddo
    #####:  890:      P=1
      34*:  891:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
branch  2 never executed (fallthrough)
branch  3 never executed
branch  4 taken 94% (fallthrough)
branch  5 taken 6%
      34*:  892:         P = P* AR(i)
        -:  893:      enddo
    #####:  894:      end   
        -:  895: 
function serprodr1_ called 0 returned 0% blocks executed 0%
    #####:  896:      subroutine serprodr1(AR,N,NL,P)
        -:  897:      real AR(N)
        -:  898:      real P,NL
       9*:  899:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
       9*:  900:         AR(i) = i+NL
        -:  901:      enddo
    #####:  902:      P=1.
       9*:  903:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
       9*:  904:         P = P* AR(i)
        -:  905:      enddo
    #####:  906:      end
        -:  907:     
function serlog1_ called 5 returned 100% blocks executed 92%
        5:  908:      subroutine serlog1(AR,N,LAND,LOR,LEQV,LNEQV)
        -:  909:      logical AR(N)
        -:  910:      logical LAND,LOR,LEQV,LNEQV
        5:  911:      do i=1,N,2
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       40:  912:         AR(i) = .true.
      40*:  913:         AR(i+1)=.false.          
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -:  914:      enddo
        5:  915:      LAND=AR(1)
        5:  916:      LOR=AR(1)
        -:  917:C      LEQV=.true.
        -:  918:C      LNEQV=.false.
        5:  919:       LEQV=AR(1)
        5:  920:       LNEQV=AR(1)
       80:  921:      do i=2,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       75:  922:         LAND = LAND .and. AR(i)
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     155*:  923:         LOR = LOR .or.AR(i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  924:      enddo
       80:  925:      do i=2,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       80:  926:         LEQV = LEQV .eqv. AR(i)
        -:  927:      enddo
       80:  928:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       80:  929:         LNEQV = LNEQV .neqv. AR(i)
        -:  930:      enddo
        5:  931:      end   
        -:  932:
        -:  933:
function ansyes_ called 16 returned 100% blocks executed 100%
       16:  934:      subroutine ansyes(name)
        -:  935:      character*7 name
       16:  936:      print *,name,'  -  complete'
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
       16:  937:      end
function ansno_ called 0 returned 0% blocks executed 0%
    #####:  938:      subroutine ansno(name)
        -:  939:      character*7 name
    #####:  940:      print *,name,'  -  ***error'
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  941:      end
