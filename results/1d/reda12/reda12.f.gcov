        -:    0:Source:results/1d/reda12/reda12.f
        -:    0:Graph:./results\1d\reda12\reda12.gcno
        -:    0:Data:./results\1d\reda12\reda12.gcda
        -:    0:Runs:1
function MAIN__ called 1 returned 100% blocks executed 100%
        1:    1:      program REDA12
        -:    2:
        -:    3:c    TESTING OF THE REDUCTION_GROUP DIRECTIVE,REDUCTION_START
        -:    4:c    DIRECTIVE,REDUCTION_WAIT DIRECTIVE.
        -:    5:c    REDUCTION GROUPE IS EXECUTED FOR DISTRIBUTED ARRAY A(N).  
        -:    6:c
        -:    7:
        1:    8:      print *,'===START OF REDA12========================'
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:    9:C --------------------------------------------------
        1:   10:      call reda1201
call    0 returned 100%
        -:   11:C --------------------------------------------------
        1:   12:      call reda1202
call    0 returned 100%
        -:   13:C --------------------------------------------------
        1:   14:       call reda1203
call    0 returned 100%
        -:   15:C --------------------------------------------------
        1:   16:       call reda1204
call    0 returned 100%
        -:   17:C --------------------------------------------------
        -:   18:C
        1:   19:      print *,'=== END OF REDA12 ========================= '    
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
function main called 1 returned 100% blocks executed 100%
        1:   20:      end
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:   21:
        -:   22:
        -:   23:C ----------------------------------------------------REDA1201
function reda1201_ called 1 returned 100% blocks executed 79%
        1:   24:      subroutine REDA1201
        -:   25:      integer, parameter :: N = 16,NL=1000
        -:   26:      character*8 tname
        1:   27:      integer, allocatable :: A(:),C(:)
        -:   28:      integer isum1,isumt1 
        -:   29:      integer imax1,imaxt1 ,ni,imin1,imint1
        -:   30:                 
        -:   31:cdvm$ distribute A(*)     
        -:   32:cdvm$ reduction_group smaxmin
        1:   33:      tname='REDA1201'
       1*:   34:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:   35:      NNL=NL 
        1:   36:      NN=N
        1:   37:      call sersum1m(C,NN,NNL,isum1)
        -:   38:
        -:   39:*dvm$ parallel (i) on A(i)
       17:   40:      do i=1,N
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
       17:   41:         A(i) = i+NL
        -:   42:      enddo
        -:   43:
        1:   44:      ni=N/2-1
        1:   45:      A(ni)=N+1+NL
        1:   46:      imax1=N+1+NL
        -:   47:
        -:   48:cdvm$ remote_access (A(1))
        1:   49:      imaxt1=A(1)  
        -:   50:
        1:   51:      ni=N/2
        1:   52:      A(ni)=-(N+1+NL)
        1:   53:      imin1=-(N+1+NL)
        -:   54:
        -:   55:cdvm$ remote_access (A(1))      
        1:   56:      imint1=A(1)
        -:   57:  
        1:   58:      isumt1 = 0
        -:   59:
        -:   60:*dvm$ parallel (i) on A(i),
        -:   61:*dvm$*reduction(smaxmin:sum(isumt1),max(imaxt1),min(imint1))
       17:   62:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:   63:         isumt1 = isumt1+A(i)
       16:   64:         if (A(i).GT.imaxt1) imaxt1=A(i)
       17:   65:         if (A(i).LT.imint1) imint1=A(i)
        -:   66:      enddo
        -:   67:
        -:   68:cdvm$ reduction_start smaxmin
        -:   69:cdvm$ reduction_wait smaxmin
        -:   70:
        -:   71:      if ((isum1 .eq.isumt1) .and.(imax1 .eq.imaxt1)
        1:   72:     *   .and.(imin1 .eq.imint1))   then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:   73:          call ansyes(tname)
call    0 returned 100%
        -:   74:      else
    #####:   75:          call ansno(tname)
call    0 never executed
        -:   76:      endif 
       1*:   77:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   78:
        1:   79:      end
        -:   80:
        -:   81:C -----------------------------------------------------REDA1202
function reda1202_ called 1 returned 100% blocks executed 84%
        1:   82:      subroutine REDA1202
        -:   83:      integer, parameter :: N = 16, NL=1000
        -:   84:      character*8 tname
        1:   85:      integer, allocatable :: A(:),C(:)
        -:   86:      integer iprod1,iprodt1 
        1:   87:      logical, allocatable :: B(:),CL(:)
        -:   88:      logical land1,landt1,lor1,leqv1,lneqv1
        -:   89:                 
        -:   90:cdvm$ distribute A(*)     
        -:   91:cdvm$ align B(I) with A(I)
        -:   92:cdvm$ reduction_group prodand      
        1:   93:      tname='REDA1202'
       1*:   94:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
       1*:   95:      allocate (B(N),CL(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:   96:      NNL=NL
        1:   97:      NN=N
        2:   98:      call serprod1(C,NN,NNL,iprod1)
        1:   99:      call serlog1(CL,NN,land1,lor1,leqv1,lneqv1)  
        -:  100:               
        -:  101:*dvm$ parallel (i) on B(i)
        1:  102:      do i=1,N,2
call    0 returned 100%
        8:  103:         B(i) = .true.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  104:      enddo
        -:  105:*dvm$ parallel (i) on B(i+1)
        8:  106:      do i=1,N-1,2
        8:  107:         B(i+1)=.false.
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  108:      enddo
        -:  109:
        -:  110:cdvm$ remote_access (B(1))
        1:  111:      landt1 = B(1)
        -:  112:
        -:  113:*dvm$ parallel (i) on A(i)
       17:  114:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       17:  115:         A(i) = i+NL
        -:  116:      enddo
        -:  117:  
        -:  118:      iprodt1 = 1
        -:  119:
        -:  120:*dvm$ parallel (i) on A(i),
        -:  121:*dvm$*reduction(prodand:product( iprodt1 ),and(landt1))
       17:  122:      do i=1,N
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
       16:  123:         iprodt1 = iprodt1*A(i)
       32:  124:         landt1 = landt1 .and.B(i)
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        -:  125:      enddo
        -:  126:
        -:  127:cdvm$ reduction_start prodand
        -:  128:
        -:  129:*dvm$ parallel (i) on A(i)
       17:  130:      do  i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  131:         A(i) = i+NL
        -:  132:      enddo
        -:  133:
        -:  134:cdvm$ reduction_wait prodand
        -:  135:
        -:  136:      if ((iprod1 .eq.iprodt1)
        1:  137:     *.and. (land1 .eqv.landt1)) then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  138:          call ansyes(tname)
call    0 returned 100%
        -:  139:       else
    #####:  140:          call ansno(tname)
call    0 never executed
        -:  141:      endif 
       1*:  142:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
       1*:  143:      deallocate (B,CL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  144: 
        1:  145:      end
        -:  146:
        -:  147:
        -:  148:C ----------------------------------------------------REDA1203
function reda1203_ called 1 returned 100% blocks executed 83%
        1:  149:      subroutine REDA1203
        -:  150:      integer, parameter :: N = 8,NL=1000
        -:  151:      character*8 tname
        1:  152:      integer, allocatable :: A(:),C(:)
        -:  153:      integer imax1,imaxt1 ,ni,imin1,imint1,it1,it2,lit
        -:  154:      integer imaxloct1,iminloct1
        -:  155:cdvm$ distribute A(*)    
        -:  156:cdvm$ reduction_group locmaxmin
        -:  157:c dvm$ reduction_group maxminloc
        1:  158:      tname='REDA1203'
       1*:  159:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 never executed
        -:  160:      
        -:  161:*dvm$ parallel (i) on A(i)
        9:  162:      do i=1,N
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
        9:  163:         A(i) = i+NL
        -:  164:      enddo
        -:  165:
        1:  166:      ni=N/2+2
        1:  167:      A(ni)=N+1+NL
        1:  168:      imax1=N+1+NL
        -:  169:
        -:  170:cdvm$ remote_access (A(1))
        1:  171:      imaxt1=A(1)  
        -:  172:
        1:  173:      imaxloct1=imaxt1
        1:  174:      ni1=N/2+1
        1:  175:      A(ni1)=-(N+1+NL)
        1:  176:      imin1=-(N+1+NL)
        -:  177:
        -:  178:cdvm$ remote_access (A(1))      
        1:  179:      imint1=A(1)
        -:  180:
        1:  181:      iminloct1=imint1
        1:  182:      lit=1
        1:  183:      it1=0
        1:  184:      it2=0
        -:  185:
        -:  186:*dvm$ parallel (i) on A(i),
        -:  187:*dvm$*reduction(locmaxmin:max( imaxt1 ),
        -:  188:*dvm$*maxloc( imaxloct1,it1,lit),
        -:  189:*dvm$*minloc( iminloct1,it2,lit))
        9:  190:      do i=1,N
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
        8:  191:         if (A(i).GT.imaxt1) imaxt1 =A(i)
        8:  192:         if (A(i).GT.imaxloct1) then
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        4:  193:	   imaxloct1=A(i)
        4:  194:           it1=i 
        -:  195:         endif
        9:  196:         if (A(i).LT.iminloct1) then
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        1:  197:           iminloct1=A(i)
        1:  198:           it2=i
        -:  199:         endif
        -:  200:      enddo
        -:  201:
        -:  202:cdvm$ reduction_start locmaxmin
        -:  203:cdvm$ reduction_wait locmaxmin
        -:  204:
        -:  205:      if ((imaxloct1.eq.imax1).and.(iminloct1.eq.imin1)
        -:  206:     *.and.(imaxt1.eq.imaxloct1).and.(it1.eq.ni)
        1:  207:     *.and.(it2.eq.ni1) )   then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        1:  208:          call ansyes(tname)
call    0 returned 100%
        -:  209:      else
    #####:  210:          call ansno(tname)
call    0 never executed
        -:  211:      endif 
       1*:  212:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  213:
        1:  214:      end
        -:  215:
        -:  216:
        -:  217:C ----------------------------------------------------REDA1204
function reda1204_ called 1 returned 100% blocks executed 83%
        1:  218:      subroutine REDA1204
        -:  219:      integer, parameter :: N = 16
        -:  220:      real, parameter :: NL=1000.
        -:  221:      character*8 tname
        1:  222:      real, allocatable :: A(:),C(:)
        -:  223:      real isum1,isumt1
        -:  224:      real imax1,imaxt1 ,imin1,imint1
        -:  225:      real imaxloct1,iminloct1,NNL
        -:  226:      integer it1,it2,ni,ni1,lit          
        -:  227:
        -:  228:cdvm$ distribute A(*)     
        -:  229:cdvm$ reduction_group locsumloc
        -:  230:
        1:  231:      tname='REDA1204'
       1*:  232:      allocate (A(N),C(N))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        1:  233:      NNL=NL 
        1:  234:      NN=N
        1:  235:      call sersum1mr(C,NN,NNL,isum1)
        -:  236:
        -:  237:*dvm$ parallel (i) on A(i)
       17:  238:      do i=1,N
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
       17:  239:         A(i) = i+NL
        -:  240:      enddo
        -:  241:
        1:  242:      ni=N/2+1
        1:  243:      A(ni)=N+1.+NL
        1:  244:      imax1=N+1.+NL
        -:  245:
        -:  246:cdvm$ remote_access (A(1))
        1:  247:      imaxt1=A(1)  
        -:  248:
        1:  249:      imaxloct1=imaxt1
        1:  250:      ni1=N/2+2
        1:  251:      A(ni1)=-(N+1.+NL)
        1:  252:      imin1=-(N+1.+NL)
        -:  253:
        -:  254:cdvm$ remote_access (A(1))      
        1:  255:      imint1=A(1)
        -:  256:
        1:  257:      iminloct1=imint1
        1:  258:      isumt1 = 0.
        1:  259:      lit=1
        1:  260:      it1=0
        1:  261:      it2=0
        -:  262:
        -:  263:*dvm$ parallel (i) on A(i),
        -:  264:*dvm$*reduction(locsumloc:sum( isumt1 ),
        -:  265:*dvm$*maxloc( imaxloct1,it1,lit),minloc( iminloct1,it2,lit ))
       17:  266:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       16:  267:         isumt1 = isumt1+A(i)
       16:  268:         if (A(i).GT.imaxloct1) then
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        8:  269:           imaxloct1=A(i)
        8:  270:           it1=i
        -:  271:         endif         
       17:  272:         if (A(i).LT.iminloct1) then
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        1:  273:           iminloct1=A(i)
        1:  274:           it2=i
        -:  275:         endif
        -:  276:      enddo
        -:  277:
        -:  278:cdvm$ reduction_start locsumloc
        -:  279:cdvm$ reduction_wait locsumloc
        -:  280:      if ((imaxloct1.eq.imax1).and.(iminloct1.eq.imin1)
        -:  281:     *.and.(isumt1.eq.isum1).and.(it1.eq.ni)
        1:  282:     *.and.(it2.eq.ni1) )   then     
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        1:  283:          call ansyes(tname)
call    0 returned 100%
        -:  284:      else
    #####:  285:          call ansno(tname)
call    0 never executed
        -:  286:      endif 
       1*:  287:      deallocate (A,C)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  288:
        1:  289:      end
        -:  290:
        -:  291:C -----------------------------------------------------
        -:  292:
function sersum1_ called 0 returned 0% blocks executed 0%
    #####:  293:      subroutine sersum1(AR,N,NL,S)
        -:  294:      integer AR(N)
        -:  295:      integer S,NL
    #####:  296:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  297:         AR(i) = i+NL
        -:  298:      enddo
    #####:  299:      S=0
    #####:  300:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  301:         s = s+ AR(i)
        -:  302:      enddo
    #####:  303:      end   
        -:  304:   
function sersum1m_ called 1 returned 100% blocks executed 100%
        1:  305:      subroutine sersum1m(AR,N,NL,S)
        -:  306:      integer AR(N)
        -:  307:      integer S,NL
       17:  308:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  309:         AR(i) = i+NL
        -:  310:      enddo
        1:  311:      ni=N/2-1
        1:  312:      AR(ni)=N+1+NL
        1:  313:      ni=N/2
        1:  314:      AR(ni)=-(N+1+NL)
        1:  315:      S=0
       17:  316:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  317:         s = s+ AR(i)
        -:  318:      enddo
        1:  319:      end 
        -:  320:  
function sersum1mr_ called 1 returned 100% blocks executed 100%
        1:  321:      subroutine sersum1mr(AR,N,NL,S)
        -:  322:      real AR(N)
        -:  323:      real S,NL
       17:  324:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  325:         AR(i) = i+NL
        -:  326:      enddo
        1:  327:      ni=N/2+1
        1:  328:      AR(ni)=N+1.+NL
        1:  329:      ni=N/2+2
        1:  330:      AR(ni)=-(N+1.+NL)
        1:  331:      S=0.
       17:  332:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  333:         S = S+ AR(i)
        -:  334:      enddo
        1:  335:      end  
        -:  336:  
function serprod1_ called 0 returned 0% blocks executed 0%
       1*:  337:      subroutine serprod1(AR,N,NL,P)
        -:  338:      integer AR(N)
        -:  339:      integer P,NL
      17*:  340:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 taken 6% (fallthrough)
branch  3 taken 94%
      17*:  341:         AR(i) = i+NL
        -:  342:      enddo
    #####:  343:      P=1
      17*:  344:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 taken 94% (fallthrough)
branch  3 taken 6%
      17*:  345:         P = P* AR(i)
        -:  346:      enddo
    #####:  347:      end   
        -:  348: 
function serprodr1_ called 0 returned 0% blocks executed 0%
    #####:  349:      subroutine serprodr1(AR,N,NL,P)
        -:  350:      real AR(N)
        -:  351:      real P,NL
    #####:  352:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  353:         AR(i) = i+NL
        -:  354:      enddo
    #####:  355:      P=1.
    #####:  356:      do i=1,N
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  357:         P = P* AR(i)
        -:  358:      enddo
    #####:  359:      end
        -:  360:     
function serlog1_ called 1 returned 100% blocks executed 89%
        1:  361:      subroutine serlog1(AR,N,LAND,LOR,LEQV,LNEQV)
        -:  362:      logical AR(N)
        -:  363:      logical LAND,LOR,LEQV,LNEQV
        1:  364:      do i=1,N,2
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:  365:         AR(i) = .true.
       8*:  366:         AR(i+1)=.false.          
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -:  367:      enddo
        1:  368:      LAND=AR(1)
        1:  369:      LOR=AR(1)
        1:  370:      LEQV=AR(1)
        1:  371:      LNEQV=AR(1)
       16:  372:      do i=2,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       15:  373:         LAND = LAND .and. AR(i)
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      31*:  374:         LOR = LOR .or.AR(i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  375:      enddo
        1:  376:      do i=1,N,2
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       8*:  377:         LEQV = LEQV .eqv. AR(i)
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -:  378:      enddo
       17:  379:      do i=1,N
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       17:  380:         LNEQV = LNEQV .neqv. AR(i)
        -:  381:      enddo
        1:  382:      end   
        -:  383:
function ansyes_ called 4 returned 100% blocks executed 100%
        4:  384:      subroutine ansyes(name)
        -:  385:      character*8 name
        4:  386:      print *,name,'  -  complete'
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
        4:  387:      end
function ansno_ called 0 returned 0% blocks executed 0%
    #####:  388:      subroutine ansno(name)
        -:  389:      character*8 name
    #####:  390:      print *,name,'  -  ***error'
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:  391:      end
        -:  392:   
